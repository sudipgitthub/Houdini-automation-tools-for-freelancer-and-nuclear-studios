<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <shelfSet name="shelf_set_1" label="Create and Refine">
    <memberToolshelf name="xLab"/>
    <memberToolshelf name="create"/>
    <memberToolshelf name="modify"/>
    <memberToolshelf name="model"/>
    <memberToolshelf name="polygon"/>
    <memberToolshelf name="deform"/>
    <memberToolshelf name="texture"/>
    <memberToolshelf name="rigging"/>
    <memberToolshelf name="characters"/>
    <memberToolshelf name="constraints"/>
    <memberToolshelf name="groomtools"/>
    <memberToolshelf name="guidemodify"/>
    <memberToolshelf name="terrainfx"/>
    <memberToolshelf name="simplefx"/>
    <memberToolshelf name="volume"/>
  </shelfSet>

  <toolshelf name="groomtools" label="Hair Utils">
    <memberTool name="object_groom_addfur"/>
    <memberTool name="object_groom_guidegroomempty"/>
    <memberTool name="object_groom_guidegroom"/>
    <memberTool name="object_groom_groommerge"/>
    <memberTool name="object_groom_animateguides"/>
    <memberTool name="object_groom_simguides"/>
    <memberTool name="object_groom_hairgen"/>
    <memberTool name="object_groom_isolateparts"/>
    <memberTool name="object_groom_togglehairdisplay"/>
    <memberTool name="object_groom_haircardgen"/>
    <memberTool name="object_groom_haircardtexture"/>
  </toolshelf>

  <toolshelf name="polygon" label="Polygon">
    <memberTool name="sop_topobuild"/>
    <memberTool name="sop_polydraw"/>
    <memberTool name="sop_curve::2.0_polygon"/>
    <memberTool name="sop_polyextrude::2.0"/>
    <memberTool name="sop_polybevel::3.0"/>
    <memberTool name="sop_polybridge"/>
    <memberTool name="sop_polysplit::2.0"/>
    <memberTool name="sop_edgeloop"/>
    <memberTool name="sop_polyreduce::2.0"/>
    <memberTool name="sop_polyfill"/>
    <memberTool name="sop_polyexpand2d"/>
    <memberTool name="sop_edgecollapse"/>
    <memberTool name="sop_edgecusp"/>
    <memberTool name="sop_edgeflip"/>
    <memberTool name="sop_edgedivide"/>
    <memberTool name="sop_dissolve::2.0"/>
    <memberTool name="geometry_knife"/>
    <memberTool name="sop_clip::2.0"/>
    <memberTool name="sop_subdivide"/>
    <memberTool name="sop_facet"/>
    <memberTool name="sop_pointweld"/>
    <memberTool name="sop_fuse::2.0"/>
    <memberTool name="geometry_snap"/>
    <memberTool name="sop_smooth::2.0"/>
    <memberTool name="geometry_curvefromedges"/>
    <memberTool name="sop_polyhinge"/>
  </toolshelf>

  <toolshelf name="model" label="Model">
    <memberTool name="sop_revolve::2.0"/>
    <memberTool name="geometry_loft"/>
    <memberTool name="sop_skin"/>
    <memberTool name="sop_rails"/>
    <memberTool name="sop_sweep::2.0"/>
    <memberTool name="sop_creep"/>
    <memberTool name="sop_ray"/>
    <memberTool name="sop_boolean::2.0"/>
    <memberTool name="geometry_voronoifracture"/>
    <memberTool name="sop_topobuild"/>
    <memberTool name="sop_carve"/>
    <memberTool name="sop_convert"/>
    <memberTool name="sop_refine"/>
    <memberTool name="sop_reverse"/>
    <memberTool name="sop_sculpt::2.0"/>
    <memberTool name="sop_scatter::2.0"/>
    <memberTool name="sop_clusterpoints"/>
    <memberTool name="geo_group"/>
    <memberTool name="sop_edit"/>
    <memberTool name="sop_visibility"/>
  </toolshelf>

  <toolshelf name="deform" label="Deform">
    <memberTool name="geometry_twist"/>
    <memberTool name="sop_bend"/>
    <memberTool name="geometry_lineartaper"/>
    <memberTool name="geometry_squashstretch"/>
    <memberTool name="sop_bulge"/>
    <memberTool name="sop_lattice"/>
    <memberTool name="sop_fractal"/>
    <memberTool name="geometry_mountain"/>
    <memberTool name="geometry_waves"/>
    <memberTool name="sop_ripple::2.0"/>
    <memberTool name="object_morph"/>
  </toolshelf>

  <toolshelf name="create" label="Create">
    <memberTool name="sop_box"/>
    <memberTool name="geometry_sphere"/>
    <memberTool name="geometry_tube"/>
    <memberTool name="sop_torus"/>
    <memberTool name="sop_grid"/>
    <memberTool name="object_null"/>
    <memberTool name="geometry_line"/>
    <memberTool name="geometry_circle"/>
    <memberTool name="sop_curve::2.0_bezier"/>
    <memberTool name="geometry_drawcurve"/>
    <memberTool name="object_path"/>
    <memberTool name="geometry_spraypaint"/>
    <memberTool name="sop_font"/>
    <memberTool name="geometry_platonic"/>
    <memberTool name="sop_lsystem"/>
    <memberTool name="sop_metaball"/>
    <memberTool name="geometry_file"/>
    <memberTool name="sop_spiral"/>
    <memberTool name="geometry_helix"/>
    <memberTool name="quickshapes"/>
  </toolshelf>

  <toolshelf name="modify" label="Modify">
    <memberTool name="object_combine"/>
    <memberTool name="geometry_extract"/>
    <memberTool name="geometry_mirror"/>
    <memberTool name="geometry_copy"/>
    <memberTool name="geometry_duplicate"/>
    <memberTool name="tool_align"/>
    <memberTool name="object_matchtransform"/>
    <memberTool name="object_centerpivot"/>
    <memberTool name="object_movetopivot"/>
    <memberTool name="object_freeze"/>
    <memberTool name="object_bakeanimation"/>
    <memberTool name="generic_delete"/>
    <memberTool name="generic_hide"/>
    <memberTool name="object_parent"/>
  </toolshelf>

  <toolshelf name="guidemodify" label="Guide Process">
    <memberTool name="sop_groom_guideinit"/>
    <memberTool name="sop_groom_curveadvect"/>
    <memberTool name="object_groom"/>
    <memberTool name="sop_groom_reguide"/>
    <memberTool name="sop_groom_guideprocess_setdir"/>
    <memberTool name="sop_groom_guideprocess_length"/>
    <memberTool name="sop_groom_guideprocess_lift"/>
    <memberTool name="sop_groom_guideprocess_straighten"/>
    <memberTool name="sop_groom_guideprocess_smooth"/>
    <memberTool name="sop_groom_guideprocess_frizz"/>
    <memberTool name="sop_groom_guideprocess_bend"/>
    <memberTool name="sop_groom_hairclump"/>
    <memberTool name="sop_groom_drawpartingline"/>
    <memberTool name="sop_groom_whitehair"/>
  </toolshelf>

  <toolshelf name="characters" label="Characters">
    <memberTool name="object_simplebiped"/>
    <memberTool name="object_simplefemale"/>
    <memberTool name="object_simplemale"/>
    <memberTool name="object_mocapbiped1"/>
    <memberTool name="object_mocapbiped2"/>
    <memberTool name="object_mocapbiped3"/>
    <memberTool name="object_mocapbiped3"/>
  </toolshelf>

  <toolshelf name="xLab" label="xLab">
    <memberTool name="filesBrowser"/>
    <memberTool name="saveFile++"/>
    <memberTool name="cameraViewer"/>
    <memberTool name="cacheBrowser"/>
    <memberTool name="renderViewer"/>
    <memberTool name="deadline"/>
    <memberTool name="viewportFlipbook"/>
    <memberTool name="openGlFlipbook"/>
    <memberTool name="flipbookBrowser"/>
    <memberTool name="xCopy"/>
    <memberTool name="xPaste"/>
  </toolshelf>

  <toolshelf name="simplefx" label="Simple FX">
    <memberTool name="geometry_vellumsimplecloth"/>
    <memberTool name="geometry_vellumsimplesoftbody"/>
    <memberTool name="geometry_rbdsimplefracture"/>
    <memberTool name="geometry_rbdsimpleguided"/>
    <memberTool name="geometry_muzzleflash"/>
    <memberTool name="geometry_pyrosimplebillowysmoke"/>
    <memberTool name="geometry_spyro_gpuburst"/>
    <memberTool name="geometry_spyro_gputorch"/>
    <memberTool name="geometry_pyrosimplefireball"/>
    <memberTool name="geometry_spyro_airexplosion"/>
    <memberTool name="geometry_spyro_groundexplosion"/>
    <memberTool name="geometry_spyro_shockwave"/>
    <memberTool name="geometry_spyro_campfire"/>
    <memberTool name="geometry_pyrosimplefirespread"/>
  </toolshelf>

  <toolshelf name="constraints" label="Constraints">
    <memberTool name="object_constraintparentblend"/>
    <memberTool name="object_constraintblend"/>
    <memberTool name="object_constraintlookat"/>
    <memberTool name="object_constraintpath"/>
    <memberTool name="object_constraintpoints"/>
    <memberTool name="object_constraintsurface"/>
    <memberTool name="object_constrainttransform"/>
    <memberTool name="object_blendpose"/>
    <memberTool name="object_lagobject"/>
    <memberTool name="object_jiggleobject"/>
    <memberTool name="object_constraintgamepad"/>
    <memberTool name="sop_constraintnetwork"/>
    <memberTool name="object_constrainttoggle"/>
    <memberTool name="object_constraintbake"/>
    <memberTool name="object_constraintdelete"/>
  </toolshelf>

  <toolshelf name="volume" label="Volume">
    <memberTool name="geometry_fogvolume"/>
    <memberTool name="geometry_vdbfrompolygons"/>
    <memberTool name="geometry_vdbfromparticles"/>
    <memberTool name="geometry_paintcolorvolume"/>
    <memberTool name="geometry_paintfogvolume"/>
    <memberTool name="geometry_paintsdfvolume"/>
    <memberTool name="geometry_volumerasterizepoints"/>
    <memberTool name="geometry_volumerasterizeparticles"/>
    <memberTool name="geometry_volumerasterizecurve"/>
    <memberTool name="geometry_convertvdb"/>
  </toolshelf>

  <toolshelf name="rigging" label="Rigging">
    <memberTool name="object_bones"/>
    <memberTool name="object_bonesfromcurve"/>
    <memberTool name="object_pose"/>
    <memberTool name="rigging_ikfromobjects"/>
    <memberTool name="rigging_ikfrombones"/>
    <memberTool name="object_capturegeometry"/>
    <memberTool name="object_editcaptureregion"/>
    <memberTool name="object_editcaptureweight"/>
    <memberTool name="object_editcaptureblend"/>
    <memberTool name="object_mirrorcapture"/>
    <memberTool name="object_paintcapturelayer"/>
    <memberTool name="object_aligncapturepose"/>
    <memberTool name="sop_deltamush"/>
    <memberTool name="sop_comb"/>
  </toolshelf>

  <toolshelf name="terrainfx" label="Terrain FX">
    <memberTool name="terrain_hills"/>
    <memberTool name="terrain_mountain"/>
    <memberTool name="terrain_valley"/>
    <memberTool name="terrain_moonscape"/>
    <memberTool name="terrain_islands"/>
    <memberTool name="terrain_canyon"/>
    <memberTool name="terrain_dunes"/>
  </toolshelf>

  <toolshelf name="texture" label="Texture">
    <memberTool name="sop_uvproject"/>
    <memberTool name="sop_uvedit"/>
    <memberTool name="sop_uvbrush"/>
    <memberTool name="sop_uvfuse"/>
    <memberTool name="sop_uvflatten::3.0"/>
    <memberTool name="sop_uvpelt::2.0"/>
    <memberTool name="sop_texture"/>
    <memberTool name="sop_uvtransform::2.0"/>
    <memberTool name="sop_uvunwrap"/>
    <memberTool name="sop_uvquickshade"/>
    <memberTool name="sop_uvsmooth"/>
    <memberTool name="sop_uvlayout::3.0"/>
    <memberTool name="generic_cleartexcache"/>
  </toolshelf>

  <tool name="object_simplebiped" label="Simple Biped" icon="OBJ_simplebiped">
    <helpURL>operator:Object/simplebiped</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Characters</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils
import toolutils

objecttoolutils.genericTool(kwargs, 'simplebiped', clicktoplace=False)
activepane = toolutils.activePane(kwargs)
if isinstance(activepane, hou.SceneViewer):
    activepane.enterViewState()
]]></script>
  </tool>

  <tool name="object_simplefemale" label="Simple Female" icon="OBJ_simplefemale">
    <helpURL>operator:Object/simplefemale</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Characters</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils
import toolutils

objecttoolutils.genericTool(kwargs, 'simplefemale', clicktoplace=False)
activepane = toolutils.activePane(kwargs)
if isinstance(activepane, hou.SceneViewer):
    activepane.enterViewState()
]]></script>
  </tool>

  <tool name="object_simplemale" label="Simple Male" icon="OBJ_simplemale">
    <helpURL>operator:Object/simplemale</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Characters</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils
import toolutils

objecttoolutils.genericTool(kwargs, 'simplemale', clicktoplace=False)
activepane = toolutils.activePane(kwargs)
if isinstance(activepane, hou.SceneViewer):
    activepane.enterViewState()
]]></script>
  </tool>

  <tool name="object_mocapbiped1" label="Mocap Biped 1" icon="CROWDS_agent">
    <helpURL>operator:Object/mocapbiped1</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Characters</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils
import toolutils

objecttoolutils.genericTool(kwargs, 'mocapbiped1', clicktoplace=False)
activepane = toolutils.activePane(kwargs)
if isinstance(activepane, hou.SceneViewer):
    activepane.enterViewState()
]]></script>
  </tool>

  <tool name="object_mocapbiped2" label="Mocap Biped 2" icon="CROWDS_agent">
    <helpURL>operator:Object/mocapbiped2</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Characters</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils
import toolutils

objecttoolutils.genericTool(kwargs, 'mocapbiped2', clicktoplace=False)
activepane = toolutils.activePane(kwargs)
if isinstance(activepane, hou.SceneViewer):
    activepane.enterViewState()
]]></script>
  </tool>

  <tool name="object_mocapbiped3" label="Mocap Biped 3" icon="CROWDS_agent">
    <helpURL>operator:Object/mocapbiped3</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Characters</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils
import toolutils

objecttoolutils.genericTool(kwargs, 'mocapbiped3', clicktoplace=False)
activepane = toolutils.activePane(kwargs)
if isinstance(activepane, hou.SceneViewer):
    activepane.enterViewState()
]]></script>
  </tool>

  <tool name="object_freeze" label="Freeze" icon="SHELF_freezetransforms">
    <helpURL>tool:freeze</helpURL>
    <script scriptType="python"><![CDATA[import objecttoolutils
import toolutils


# Determine context
active_pane = toolutils.activePane(kwargs)
scene_viewer = toolutils.sceneViewer()
pwd = scene_viewer.pwd()

# Prompt selection
selected = scene_viewer.selectObjects(
                prompt = toolutils.selectionPrompt(hou.objNodeTypeCategory()),
                allow_multisel = True,
                allowed_types = ("geo",))
if len(selected) == 0:
    raise hou.Error("Nothing was selected")
objecttoolutils.freeze(selected)]]></script>
  </tool>

  <tool name="tool_align" label="Align Components" icon="SHELF_aligncomponents">
    <helpURL>tool:aligncomponents</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Copying</toolSubmenu>
    <script scriptType="python"><![CDATA[import alignutils

alignutils.interactiveAlign()
]]></script>
  </tool>

  <tool name="object_matchtransform" label="Match Transform" icon="SHELF_matchtransform">
    <helpURL>tool:matchtransform</helpURL>
    <script scriptType="python"><![CDATA[import objecttoolutils
import toolutils

scene_viewer = toolutils.sceneViewer()
targets = scene_viewer.selectObjects(
                prompt = toolutils.selectionPrompt(hou.objNodeTypeCategory()),
                allow_multisel = True)
if len(targets) == 0:
    raise hou.Error("Nothing was selected")
for target in targets:
    target.setSelected(False)
sources = scene_viewer.selectObjects(
                prompt = "Select object to match",
                quick_select = True,
                allow_multisel = False)
if len(sources) == 0:
    raise hou.Error("No object to match was selected")
xform = sources[0].worldTransform()
for target in targets:
    target.setWorldTransform(xform)
]]></script>
  </tool>

  <tool name="sop_ripple::2.0" label="Ripple" icon="SOP_ripple">
    <helpURL>operator:Sop/ripple</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/ripple</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Dynamics/Fluids</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
from soptoolutils import OrientInfo

kwargs['parms'] = { 'usecenter': True }
soptoolutils.genericTool(kwargs, 'ripple::2.0', orient=OrientInfo('up'))
]]></script>
  </tool>

  <tool name="geometry_mountain" label="Mountain" icon="SOP_mountain">
    <helpURL>operator:Sop/attribnoise</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/attribnoise</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Deform</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils
import toolutils

kwargs['parms'] = {
    'displace': 1,
    'attribs': 'P',
    'noiserange': 1,
    'amplitude': 0.25,
    'fractal': 3,
    'oct': 8,
    'rough': 0.4 }
soptoolutils.genericTool(kwargs, 'attribnoise::2.0', force_filter=True, nodename = 'mountain1')
]]></script>
  </tool>

  <tool name="geometry_waves" label="Waves" icon="SHELF_oceanwaves">
    <helpURL>tool:waves</helpURL>
    <toolSubmenu>Environments/Oceans</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

evalnode = soptoolutils.genericTool(kwargs, 'oceanevaluate', exact_node_type=False)
spectrumnode = evalnode.parent().createNode('oceanspectrum')
spectrumnode.parm('windspeed').set(10)
evalnode.setNextInput(spectrumnode)
spectrumnode.moveToGoodPosition()
]]></script>
  </tool>

  <tool name="terrain_hills" label="Terrain: Hills" icon="SHELF_terrain_fx">
    <helpURL>tool:terrain_hills</helpURL>
    <toolSubmenu>Environments/Terrain</toolSubmenu>
    <script scriptType="python"><![CDATA[import terraintoolutils
terraintoolutils.fxRockyLowLands(kwargs)
]]></script>
  </tool>

  <tool name="terrain_mountain" label="Terrain: Mountain" icon="SHELF_terrain_fx">
    <helpURL>tool:terrain_mountain</helpURL>
    <toolSubmenu>Environments/Terrain</toolSubmenu>
    <script scriptType="python"><![CDATA[import terraintoolutils
terraintoolutils.fxMountain(kwargs)
]]></script>
  </tool>

  <tool name="terrain_valley" label="Terrain: Valley" icon="SHELF_terrain_fx">
    <helpURL>tool:terrain_valley</helpURL>
    <toolSubmenu>Environments/Terrain</toolSubmenu>
    <script scriptType="python"><![CDATA[import terraintoolutils
terraintoolutils.fxValley(kwargs)
]]></script>
  </tool>

  <tool name="terrain_moonscape" label="Terrain: Moonscape" icon="SHELF_terrain_fx">
    <helpURL>tool:terrain_moonscape</helpURL>
    <toolSubmenu>Environments/Terrain</toolSubmenu>
    <script scriptType="python"><![CDATA[import terraintoolutils
terraintoolutils.fxMoonscape(kwargs)
]]></script>
  </tool>

  <tool name="terrain_islands" label="Terrain: Islands" icon="SHELF_terrain_fx">
    <helpURL>tool:terrain_islands</helpURL>
    <toolSubmenu>Environments/Terrain</toolSubmenu>
    <script scriptType="python"><![CDATA[import terraintoolutils
terraintoolutils.fxIslands(kwargs)
]]></script>
  </tool>

  <tool name="terrain_canyon" label="Terrain: Canyon" icon="SHELF_terrain_fx">
    <helpURL>tool:terrain_canyon</helpURL>
    <toolSubmenu>Environments/Terrain</toolSubmenu>
    <script scriptType="python"><![CDATA[import terraintoolutils
terraintoolutils.fxCanyon(kwargs)
]]></script>
  </tool>

  <tool name="terrain_dunes" label="Terrain: Dunes" icon="SHELF_terrain_fx">
    <helpURL>tool:terrain_dunes</helpURL>
    <toolSubmenu>Environments/Terrain</toolSubmenu>
    <script scriptType="python"><![CDATA[import terraintoolutils
terraintoolutils.fxDunes(kwargs)
]]></script>
  </tool>

  <tool name="geometry_copy" label="Copy to Points" icon="SOP_copy">
    <helpURL>operator:Sop/copytopoints</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Copying</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils

sop = soptoolutils.genericTool(kwargs, 'copytopoints::2.0')
sop.parm('resettargetattribs').pressButton()]]></script>
  </tool>

  <tool name="geometry_duplicate" label="Duplicate" icon="SOP_duplicate">
    <helpURL>operator:Sop/copyxform</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Copying</toolSubmenu>
    <script scriptType="python"><![CDATA[import toolutils
import soptoolutils

scene_viewer = toolutils.sceneViewer();
current_path = scene_viewer.pwd();
if current_path.childTypeCategory() == hou.objNodeTypeCategory():
    toolutils.genericStateTool(kwargs, 'objcopy')
else:
    node = soptoolutils.genericTool(kwargs, 'copyxform')
    activepane = toolutils.activePane(kwargs)
    if isinstance(activepane, hou.SceneViewer) and node:
        ingeo = node.inputGeometry(0)
        if ingeo:
            groupstr = node.parm('sourcegroup').evalAsString()
            bbox = ingeo.primBoundingBox(groupstr)
            node.parmTuple('p').set(bbox.center())]]></script>
  </tool>

  <tool name="geometry_curvefromedges" label="Curve from Edges" icon="SOP_convertline">
    <helpURL>operator:Sop/convertline</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Curves</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils
kwargs['parms'] = {
    'connectpath': True,
    'remove': True,
    'computelength': False }
soptoolutils.genericTool(kwargs, 'convertline', 'curvefromedges1')]]></script>
  </tool>

  <tool name="geometry_sphere" label="Sphere" icon="SOP_sphere">
    <helpURL>operator:Sop/sphere</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils
from soptoolutils import OrientInfo
rad = 0.5
# NB: Bounding box is the same regardless of hou.ui.orientationUpAxis().
kwargs['bbox'] = hou.BoundingBox(-rad, -rad, -rad, rad, rad, rad)
kwargs['parms'] = {
    'type': 'polymesh',
    'radx': rad,
    'rady': rad,
    'radz': rad }
soptoolutils.genericTool(kwargs, 'sphere', orient=OrientInfo('orient'))
]]></script>
  </tool>

  <tool name="geometry_tube" label="Tube" icon="SOP_tube">
    <helpURL>operator:Sop/tube</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils
from soptoolutils import OrientInfo
rad = 0.5
height = 1.0
if hou.ui.orientationUpAxis() == hou.orientUpAxis.Z:
    kwargs['bbox'] = hou.BoundingBox(-rad, -rad, -height/2., rad, rad, height/2.)
else:
    kwargs['bbox'] = hou.BoundingBox(-rad, -height/2., -rad, rad, height/2., rad)
kwargs['parms'] = {
    'type': 'poly',
    'rad1': rad,
    'rad2': rad,
    'height': height }
soptoolutils.genericTool(kwargs, 'tube', orient=OrientInfo('orient'))
]]></script>
  </tool>

  <tool name="sop_torus" label="Torus" icon="SOP_torus">
    <helpURL>operator:Sop/torus</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Primitive</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils
from soptoolutils import OrientInfo
orad = 0.5
irad = 0.25
if hou.ui.orientationUpAxis() == hou.orientUpAxis.Z:
    kwargs['bbox'] = hou.BoundingBox(-orad - irad, -orad - irad, -irad, orad + irad, orad + irad, irad)
else:
    kwargs['bbox'] = hou.BoundingBox(-orad - irad, -irad, -orad - irad, orad + irad, irad, orad + irad)
kwargs['parms'] = {
    'type': 'poly',
    'radx': orad,
    'rady': irad }
soptoolutils.genericTool(kwargs, 'torus', orient=OrientInfo('orient'))
]]></script>
  </tool>

  <tool name="sop_grid" label="Grid" icon="SOP_grid">
    <helpURL>operator:Sop/grid</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Primitive</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils
from soptoolutils import OrientInfo

size = 10.0
if hou.ui.orientationUpAxis() == hou.orientUpAxis.Z:
    kwargs['bbox'] = hou.BoundingBox(-size/2.0, -size/2.0, 0, size/2.0, size/2.0, 0)
else:
    kwargs['bbox'] = hou.BoundingBox(-size/2.0, 0, -size/2.0, size/2.0, 0, size/2.0)
grid = soptoolutils.genericTool(kwargs, 'grid', orient=OrientInfo('orient'))
]]></script>
  </tool>

  <tool name="geometry_platonic" label="Platonic Solids" icon="SOP_platonic">
    <helpURL>operator:Sop/platonic</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Primitive</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils
from soptoolutils import OrientInfo

rad = 0.5
# NB: Bounding box is the same regardless of hou.ui.orientationUpAxis().
kwargs['bbox'] = hou.BoundingBox(-rad, -rad, -rad, rad, rad, rad)
kwargs['parms'] = { 'radius': rad }
soptoolutils.genericTool(kwargs, 'platonic',  orient=OrientInfo('orient'))
]]></script>
  </tool>

  <tool name="geometry_line" label="Line" icon="SOP_line">
    <helpURL>operator:Sop/line</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Primitive</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils
from soptoolutils import OrientInfo

if hou.ui.orientationUpAxis() == hou.orientUpAxis.Z:
    kwargs['bbox'] = hou.BoundingBox(-1.0, -.0, -1., 1.0, .0, 1.)
else:
    kwargs['bbox'] = hou.BoundingBox(-1.0, -1., -.0, 1.0, 1., .0)
kwargs['parms'] = { 'type': 'poly' }
soptoolutils.genericTool(kwargs, 'line', orient=OrientInfo('dir'))
]]></script>
  </tool>

  <tool name="geometry_circle" label="Circle" icon="SOP_circle">
    <helpURL>operator:Sop/circle</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils
from soptoolutils import OrientInfo

if hou.ui.orientationUpAxis() == hou.orientUpAxis.Z:
    kwargs['bbox'] = hou.BoundingBox(-1.0, -.0, -1., 1.0, .0, 1.)
else:
    kwargs['bbox'] = hou.BoundingBox(-1.0, -1., -.0, 1.0, 1., .0)
kwargs['parms'] = { 'type': 'poly' }
soptoolutils.genericTool(kwargs, 'circle', orient=OrientInfo('orient'))
]]></script>
  </tool>

  <tool name="sop_box" label="Box" icon="SOP_box">
    <helpURL>operator:Sop/box</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Primitive</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils

kwargs['bbox'] = hou.BoundingBox(-0.5, -0.5, -0.5, 0.5, 0.5, 0.5)
kwargs['parms'] = {
    'type': 'polymesh',
    'divrate1': 2,
    'divrate2': 2,
    'divrate3': 2 }
soptoolutils.genericTool(kwargs, 'box')
]]></script>
  </tool>

  <tool name="geometry_helix" label="Helix" icon="SHELF_helix">
    <helpURL>operator:Sop/spiral</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Curves</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
from soptoolutils import OrientInfo
turns = 3
rad = 1
height = 1
if hou.ui.orientationUpAxis() == hou.orientUpAxis.Z:
    kwargs['bbox'] = hou.BoundingBox(-rad, -rad, 0, rad, rad, height)
else:
    kwargs['bbox'] = hou.BoundingBox(-rad, 0, -rad, rad, height, rad)
kwargs['parms'] = {
    'turns': turns,
    'height': height,
    'startradius': rad,
    'radiusincreaseperturn': 0
    }
soptoolutils.genericTool(kwargs, 'spiral', 'helix1', orient=OrientInfo('orient'))]]></script>
  </tool>

  <tool name="geometry_mirror" label="Mirror" icon="SOP_mirror">
    <helpURL>operator:Sop/mirror</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry</toolSubmenu>
    <script scriptType="python"><![CDATA[import toolutils
import soptoolutils

scene_viewer = toolutils.sceneViewer();
current_path = scene_viewer.pwd();
if current_path.childTypeCategory() == hou.objNodeTypeCategory():
    toolutils.genericStateTool(kwargs, 'objmirror')
else:
    mirror_sop = soptoolutils.genericTool(kwargs, 'mirror')
    activepane = toolutils.activePane(kwargs)
    if mirror_sop:
        inputgeo = mirror_sop.inputGeometry(0)
        if inputgeo:
            mirror_sop.parmTuple('origin').set(inputgeo.boundingBox().center())]]></script>
  </tool>

  <tool name="sop_boolean::2.0" label="Boolean" icon="SOP_boolean">
    <helpURL>operator:Sop/boolean</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
soptoolutils.addBooleanTool(kwargs)
]]></script>
  </tool>

  <tool name="geometry_fogvolume" label="Volume" icon="SOP_volume">
    <helpURL>operator:Sop/isooffset</helpURL>
    <script scriptType="python"><![CDATA[
import soptoolutils

kwargs['parms'] = {
    'output': 'fogvolume',
    'samplediv': 30 }
soptoolutils.genericTool(kwargs, 'isooffset', 'converttofog1')
]]></script>
  </tool>

  <tool name="geometry_voronoifracture" label="Shatter" icon="SOP_shatter">
    <helpURL>tool:shatter</helpURL>
    <script scriptType="python"><![CDATA[
import soptoolutils

# Create our voronoi fracture
fracture = soptoolutils.genericTool(kwargs, 'voronoifracture::2.0')

fognode = fracture.parent().createNode('isooffset', 'converttofog1')
fognode.parm("output").set('fogvolume')
fognode.parm("samplediv").set(30)

fognode.setNextInput(fracture.inputs()[0])

fognode.moveToGoodPosition()

scatternode = fracture.parent().createNode('scatter', 'chunkcenters')
scatternode.parm("forcetotal").set(True)
scatternode.parm("npts").set(10)
scatternode.parm("relaxpoints").set(False)
scatternode.setNextInput(fognode)
scatternode.moveToGoodPosition()

fracture.setNextInput(scatternode)
fracture.moveToGoodPosition()

]]></script>
  </tool>

  <tool name="geometry_squashstretch" label="Squash and Stretch" icon="SHELF_twist_squashstretch">
    <helpURL>operator:Sop/bend#squash</helpURL>
    <script scriptType="python"><![CDATA[import soptoolutils
node = soptoolutils.createBendSop(kwargs, "squashstretch1")
node.parm("enablelengthscale").set(1)
node.parm("lengthscalefolder").set(1)
node.parm("enablebend").set(0)
node.parm("bendfolder").set(0)
]]></script>
  </tool>

  <tool name="geometry_lineartaper" label="Linear Taper" icon="SHELF_twist_linear_taper">
    <helpURL>operator:Sop/bend#taper</helpURL>
    <toolMenuContext name="viewer">
      <contextOpType>Sop/bend</contextOpType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/bend</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Deform</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
node = soptoolutils.createBendSop(kwargs, "lineartaper1")
node.parm("enabletaper").set(1)
node.parm("taperfolder").set(1)
node.parm("enablebend").set(0)
node.parm("bendfolder").set(0)
]]></script>
  </tool>

  <tool name="sop_bend" label="Bend" icon="SHELF_twist_bend">
    <helpURL>operator:Sop/bend#bend</helpURL>
    <toolMenuContext name="viewer">
      <contextOpType>Sop/bend</contextOpType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/bend</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Deform</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
soptoolutils.createBendSop(kwargs, "bend1")
]]></script>
  </tool>

  <tool name="geometry_twist" label="Twist" icon="SHELF_twist_twist">
    <helpURL>operator:Sop/bend#twist</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/bend</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Deform</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
node = soptoolutils.createBendSop(kwargs, "twist1")
node.parm("enabletwist").set(1)
node.parm("twistfolder").set(1)
node.parm("enablebend").set(0)
node.parm("bendfolder").set(0)
]]></script>
  </tool>

  <tool name="geometry_loft" label="Loft" icon="SOP_loft">
    <helpURL>operator:Sop/skin#loft</helpURL>
    <script scriptType="python"><![CDATA[import soptoolutils

u_selector_only = [0]
node = soptoolutils.genericSopNodeFilterTool(kwargs, 'skin', 'loft1', False, False, True, u_selector_only)]]></script>
  </tool>

  <tool name="geometry_spyro_groundexplosion" label="Simple Ground Explosion" icon="SHELF_explosion">
    <helpURL>tool:spyro_simplegroundexplosion</helpURL>
    <script scriptType="python"><![CDATA[
import dopsparsepyrotools
dopsparsepyrotools.createGroundExplosion(kwargs, False)
]]></script>
  </tool>

  <tool name="geometry_spyro_airexplosion" label="Simple Aerial Explosion" icon="SHELF_aerial_explosion">
    <helpURL>tool:spyro_simpleairexplosion</helpURL>
    <script scriptType="python"><![CDATA[
import dopsparsepyrotools
dopsparsepyrotools.createAerialExplosion(kwargs, False)
]]></script>
  </tool>

  <tool name="geometry_spyro_gputorch" label="Simple GPU Torch" icon="SHELF_torch">
    <helpURL>tool:spyro_gputorch</helpURL>
    <script scriptType="python"><![CDATA[
import dopsparsepyrotools
dopsparsepyrotools.sopGPUTorch(kwargs)
]]></script>
  </tool>

  <tool name="geometry_spyro_gpuburst" label="Simple GPU Ground Explosion" icon="SHELF_spyro_gpuburst">
    <helpURL>tool:spyro_simplegpuexplosion</helpURL>
    <script scriptType="python"><![CDATA[
import dopsparsepyrotools
dopsparsepyrotools.sopGPUBurst(kwargs)
]]></script>
  </tool>

  <tool name="geometry_muzzleflash" label="Simple Muzzle Flash" icon="SHELF_muzzle_flash">
    <helpURL>tool:pyrosimplemuzzleflash</helpURL>
    <script scriptType="python"><![CDATA[
import dopsparsepyrotools
dopsparsepyrotools.sopMuzzleFlash(kwargs)
]]></script>
  </tool>

  <tool name="geometry_spyro_shockwave" label="Simple Shockwave" icon="SHELF_shockwave">
    <helpURL>tool:pyrosimpleshockwave</helpURL>
    <script scriptType="python"><![CDATA[
import dopsparsepyrotools
dopsparsepyrotools.createFireballShockwave(kwargs, False)
]]></script>
  </tool>

  <tool name="geometry_spyro_campfire" label="Simple Bonfire" icon="SHELF_campfire">
    <helpURL>tool:spyro_simplecampfire</helpURL>
    <script scriptType="python"><![CDATA[
import dopsparsepyrotools
dopsparsepyrotools.createBonfire(kwargs, False)
]]></script>
  </tool>

  <tool name="geometry_pyrosimplefirespread" label="Simple Spreading Fire" icon="SHELF_spyro_firespread">
    <helpURL>tool:pyrosimplefirespread</helpURL>
    <script scriptType="python"><![CDATA[
import dopsparsepyrotools

node = dopsparsepyrotools.createSopSpreadingFire(kwargs)
]]></script>
  </tool>

  <tool name="geometry_pyrosimplefireball" label="Simple Fireball" icon="SHELF_fireball">
    <helpURL>tool:pyrosimplefireball</helpURL>
    <script scriptType="python"><![CDATA[
import dopsparsepyrotools
dopsparsepyrotools.createFireball(kwargs, False)
]]></script>
  </tool>

  <tool name="geometry_pyrosimplebillowysmoke" label="Simple Billowy Smoke" icon="SHELF_smoke_heavy">
    <helpURL>tool:pyrosimplebillowysmoke</helpURL>
    <script scriptType="python"><![CDATA[
import dopsparsepyrotools
dopsparsepyrotools.createBillowySmoke(kwargs, False)
]]></script>
  </tool>

  <tool name="geometry_vellumsimplecloth" label="Simple Cloth" icon="SHELF_vellum_simplecloth">
    <helpURL>tool:vellumsimplecloth</helpURL>
    <script scriptType="python"><![CDATA[
import doptoolutils
import doppoptoolutils

node = doppoptoolutils.createSopVellum(kwargs, 'cloth')
]]></script>
  </tool>

  <tool name="geometry_vellumsimplesoftbody" label="Simple Softbody" icon="SHELF_vellum_softbody">
    <helpURL>tool:vellumsimplesoftbody</helpURL>
    <script scriptType="python"><![CDATA[
import doptoolutils
import doppoptoolutils

node = doppoptoolutils.createSopVellum(kwargs, 'softbody')
]]></script>
  </tool>

  <tool name="geometry_rbdsimplefracture" label="Simple Fracture" icon="SOP_rbdmaterialfracture">
    <helpURL>operator:Sop/rbdmaterialfracture</helpURL>
    <script scriptType="python"><![CDATA[
import doprbdtoolutils

node = doprbdtoolutils.createSopRBD(kwargs, 'fracture')
]]></script>
  </tool>

  <tool name="geometry_rbdsimpleguided" label="Simple Guided RBDs" icon="SHELF_rbd_guided">
    <helpURL>tool:rbdsimpleguided</helpURL>
    <script scriptType="python"><![CDATA[
import doprbdtoolutils

node = doprbdtoolutils.createSopRBD(kwargs, 'guided sim')
]]></script>
  </tool>

  <tool name="sop_metaball" label="Metaball" icon="SOP_metaball">
    <helpURL>operator:Sop/metaball</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/metaball</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Metaball</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

kwargs['bbox'] = hou.BoundingBox(-0.5, -0.5, -0.5, 0.5, 0.5, 0.5)
soptoolutils.genericTool(kwargs, 'metaball', merge_context=True)]]></script>
  </tool>

  <tool name="geometry_knife" label="Knife" icon="SHELF_knife">
    <helpURL>operator:Sop/clip</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/clip</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
import toolutils
from soptoolutils import OrientInfo

kwargs['parms'] = { 'clipop': 'both' }
knife_sop = soptoolutils.genericTool(kwargs, 'clip::2.0', 'knife1', custom = False,
                                     orient = OrientInfo('dir'))
del kwargs['parms']
knife_sop.setCreatorState('knife')
knife_sop.setBuiltExplicitly(False)
activepane = toolutils.activePane(kwargs)
if isinstance(activepane, hou.SceneViewer):
    sceneviewer = toolutils.sceneViewer()
    knife_sop.setCurrent(True, True)
    sceneviewer.enterCurrentNodeState()
    sceneviewer.runStateCommand("knife")
]]></script>
  </tool>

  <tool name="sop_clip::2.0" label="Clip" icon="SOP_clip">
    <helpURL>operator:Sop/clip</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
import toolutils
from soptoolutils import OrientInfo

clip_sop = soptoolutils.genericTool(kwargs, 'clip::2.0', orient = OrientInfo('dir'))
activepane = toolutils.activePane(kwargs)
if isinstance(activepane, hou.SceneViewer) and clip_sop:
    inputgeo = clip_sop.inputGeometry(0)
    if inputgeo:
        clip_sop.parmTuple('origin').set(inputgeo.boundingBox().center())]]></script>
  </tool>

  <tool name="object_centerpivot" label="Move Pivot to Center" icon="SHELF_center_pivot">
    <helpURL>tool:centerpivot</helpURL>
    <script scriptType="python"><![CDATA[import toolutils

scene_viewer = None
activepane = toolutils.activePane(kwargs)
parent = activepane.pwd()
if activepane.type() != hou.paneTabType.SceneViewer:
    # Use the last selected object
    if parent.childTypeCategory() != hou.objNodeTypeCategory():
        raise hou.Error("This tool cannot be executed in this context")
    selected = [child for child in parent.children() if child.isSelected()]
else:
    scene_viewer = toolutils.sceneViewer()
    selected = scene_viewer.selectObjects(
                prompt = toolutils.selectionPrompt(hou.objNodeTypeCategory()),
                allow_multisel = True,
                allowed_types = ("geo",))

if len(selected) == 0:
    raise hou.Error("Nothing was selected")

for center_obj in selected:
    display = center_obj.displayNode()
    if display is None:
        pivot = hou.Vector3(0, 0, 0)        # Use 0,0,0 by convention
    else:
        geo = display.geometry()
        pivot = geo.boundingBox().center()
    center_obj.parmTuple("p").set(pivot)

if scene_viewer is not None:
    scene_viewer.setCurrentState("pose")]]></script>
  </tool>

  <tool name="object_movetopivot" label="Move Center to Pivot" icon="SHELF_move_center_to_pivot">
    <helpURL>tool:movetopivot</helpURL>
    <script scriptType="python"><![CDATA[import toolutils

scene_viewer = None
activepane = toolutils.activePane(kwargs)
parent = activepane.pwd()
if activepane.type() != hou.paneTabType.SceneViewer:
    # Use the last selected object
    if parent.childTypeCategory() != hou.objNodeTypeCategory():
        raise hou.Error("This tool cannot be executed in this context")
    selected = [child for child in parent.children() if child.isSelected()]
else:
    scene_viewer = toolutils.sceneViewer()
    selected = scene_viewer.selectObjects(
                prompt = toolutils.selectionPrompt(hou.objNodeTypeCategory()),
                allow_multisel = True,
                allowed_types = ("geo",))

if len(selected) == 0:
    raise hou.Error("Nothing was selected")

for center_obj in selected:
    display = center_obj.displayNode()
    if display:
        geo = display.geometry()
        pivot = geo.boundingBox().center()
        sop = center_obj.createNode('xform', 'move_to_pivot1')
        sop.setInput(0, display)
        sop.moveToGoodPosition()
        sop.setDisplayFlag(True)
        if display.isRenderFlagSet():
            sop.setRenderFlag(True)
        sop.parmTuple("t").set(-pivot)
        sop.parmTuple("p").set( pivot)

if scene_viewer is not None:
    scene_viewer.setCurrentState("pose")]]></script>
  </tool>

  <tool name="geometry_extract" label="Extract" icon="SHELF_extract_object">
    <helpURL>tool:extract</helpURL>
    <script scriptType="python"><![CDATA[import toolutils
import soptoolutils

activepane = toolutils.activePane(kwargs)
if activepane.type() != hou.paneTabType.SceneViewer:
    raise hou.Error("This tool cannot run in the current pane")

scene_viewer = toolutils.sceneViewer()
nodetypename = "delete"

# Obtain a geometry selection
geo_types = (hou.geometryType.Primitives, )
selection = scene_viewer.selectGeometry(
                "Select the primitives to extract and press Enter to complete",
                geometry_types = geo_types,
                allow_obj_sel = True)
# The following will raise an exception if nothing was selected.
if len(selection.nodes()) == 0:
    raise hou.Error("Nothing was selected.")

# Create a new SOP container with the merged geometry
container = soptoolutils.createSopNodeContainer(scene_viewer, "extract_object1")
merge_sop = selection.mergedNode(container, nodetypename, True, True)
# Turn back on the display flag for merged nodes
for sop in selection.nodes():
    sop.parent().setDisplayFlag(True)

# Change our viewer to the new object
scene_viewer.setPwd(merge_sop.parent())
merge_sop.setDisplayFlag(True)
merge_sop.setRenderFlag(True)
merge_sop.setHighlightFlag(True)
merge_sop.setCurrent(True, True)
merge_sop.moveToGoodPosition()
toolutils.homeToSelectionNetworkEditorsFor(merge_sop)
scene_viewer.enterCurrentNodeState()]]></script>
  </tool>

  <tool name="object_combine" label="Combine" icon="SHELF_combine_objects">
    <helpURL>tool:combine</helpURL>
    <script scriptType="python"><![CDATA[import toolutils

scene_viewer = toolutils.sceneViewer()

# Ask for the objects to combine
selected_objects = list(scene_viewer.selectObjects(
    prompt = toolutils.selectionPrompt(hou.objNodeTypeCategory()),
    allow_multisel = True,
    allowed_types = ("geo",)))
# The following will raise an exception if nothing was selected.
if len(selected_objects) == 0:
    raise hou.Error("Nothing was selected.")

# Combine into the last picked item
current_objects = [obj for obj in selected_objects if obj.isCurrent()]
if len(current_objects) == 0:
    container = selected_objects[-1]
else:
    container = current_objects[-1]

selected_objects.remove(container)
container.combine(selected_objects)
toolutils.homeToSelectionNetworkEditorsFor(container)
]]></script>
  </tool>

  <tool name="geo_group" label="Group" icon="SOP_group">
    <helpURL>operator:Sop/groupcreate</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Group</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils
soptoolutils.genericTool(kwargs, 'groupcreate')]]></script>
  </tool>

  <tool name="sop_smooth::2.0" label="Smooth" icon="SOP_smooth">
    <helpURL>operator:Sop/smooth</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Deform</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils
selection_queries = [
  {
    'parm_name' : 'group',
    'is_required' : True,
    'prompt' : 'Select the primitives to smooth and press Enter to continue.',
    'geometry_types' : (hou.geometryType.Primitives, )
  },
  {
    'parm_name' : 'constrainedpoints',
    'is_required' : False,
    'prompt' : 'Now select the points to constrain, if any, and press Enter to complete.',
    'geometry_types' : (hou.geometryType.Points, hou.geometryType.Edges),
    'use_existing_selection' : False,
    'allow_obj_sel' : False
  },
]
soptoolutils.createCustomSelectionSopNodeFilterTool(kwargs, 'smooth::2.0',
  'smooth1', selection_queries)]]></script>
  </tool>

  <tool name="sop_uvsmooth" label="UV Smooth" icon="SOP_smooth">
    <helpURL>operator:Sop/smooth</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Texturing/UV</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils
selection_queries = [
  {
    'parm_name' : 'group',
    'is_required' : True,
    'prompt' : 'Select the UV primitives to smooth and press Enter to continue.',
    'geometry_types' : (hou.geometryType.Primitives, )
  },
  {
    'parm_name' : 'constrainedpoints',
    'is_required' : False,
    'prompt' : 'Now select the points to constrain, if any, and press Enter to complete.',
    'geometry_types' : (hou.geometryType.Points, ),
    'use_existing_selection' : False,
    'allow_obj_sel' : False
  },
]
sopnodes = soptoolutils.createCustomSelectionSopNodeFilterTool(kwargs, 'smooth::2.0',
  'uvsmooth1', selection_queries)
for node in sopnodes:
  node.parm('attributes').set(soptoolutils.findViewersUV(kwargs))]]></script>
  </tool>

  <tool name="sop_topobuild" label="TopoBuild" icon="SOP_topobuild">
    <helpURL>operator:Sop/topobuild</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import toolutils
import soptoolutils

activepane = toolutils.activePane(kwargs)
if activepane.type() == hou.paneTabType.SceneViewer:
    sopnode, template = None, None
    node = activepane.currentNode()
    if node and node.type().category() == hou.sopNodeTypeCategory():
        # continue work in the current SOP network
        sopnode = node
        topobuild = toolutils.findInputNodeOfType(sopnode, 'topobuild', True)
        if topobuild:
            inputs = topobuild.inputs()
            if len(inputs) > 1:
                # re-use the template geometry
                template = inputs[1]

    templateobj = None
    if template is None:
        # select template geometry
        for obj in activepane.selectObjects(
                    prompt = 'Select projection geometry to retopologize and press Enter to continue.',
                    allowed_types = ('geo', ),
                    allow_multisel = False):
            templateobj = obj
            activepane.currentNode().setCurrent(False, True)

    extendobj = None
    # Only prompt the user if they alraedy selected a valid node.
    if templateobj and sopnode is None:
        # select topology to extend
        for obj in activepane.selectObjects(
                prompt = 'Now select topology to extend, if any, and press Enter to complete.',
                allowed_types = ('geo', ),
                allow_multisel = False):
            extendobj = obj
            sopnode = extendobj.displayNode()

    if templateobj and template is None:
        if templateobj != extendobj:
            # create a new container if the selected object is an ancestor of sopnode
            node = sopnode
            while node:
                if node == templateobj:
                    sopnode = None
                    break
                node = node.parent()
        else:
            sopnode = None
        if sopnode:
            container = sopnode.parent()
        else:
            # create container for retopo work
            container = templateobj.parent().createNode('geo', templateobj.name() + '_retopo')
            toolutils.removeDefaultGeometryObjectContents(container)
            container.moveToGoodPosition()

        # object merge template geometry
        template = container.createNode('object_merge')
        template.parm('objpath1').set(template.relativePathTo(templateobj))
        template.parm('xformpath').set('.')
        template.moveToGoodPosition()

    if template:
        template.setTemplateFlag(True)
        if sopnode is None or not (sopnode.type().name() == 'topobuild' and len(sopnode.inputs()) > 1):
            # create new topobuild node
            topobuild = template.parent().createNode('topobuild')
            topobuild.setInput(0, sopnode)
            topobuild.setInput(1, template)
            topobuild.moveToGoodPosition()
            topobuild.setDisplayFlag(True)
            topobuild.setRenderFlag(sopnode is None or sopnode.isRenderFlagSet())

            # add visualizer
            vis = hou.viewportVisualizers.createVisualizer(hou.viewportVisualizers.type('vis_color'), hou.viewportVisualizerCategory.Node, topobuild)
            vis.setParm('colortype', 'constant')
            vis.setParm('class', 'detail')
            vis.setParm('constcolorr', 0.0)
            vis.setParm('constcolorg', 0.9)
            vis.setParm('constcolorb', 0.21)
            vis.setIsActive(True)
            sopnode = topobuild
        sopnode.setCurrent(True, True)
        activepane.enterCurrentNodeState()
elif activepane.type() == hou.paneTabType.NetworkEditor:
    soptoolutils.genericTool(kwargs, 'topobuild')
else:
    raise hou.Error("Can't run the tool in the selected pane.")]]></script>
  </tool>

  <tool name="sop_polydraw" label="PolyDraw" icon="SOP_polydraw">
    <helpURL>operator:Sop/topobuild#polydraw</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import toolutils
import soptoolutils

sop = None
activepane = toolutils.activePane(kwargs)
if isinstance(activepane, hou.SceneViewer):
    parent = activepane.pwd()
    child_type = parent.childTypeCategory()
    if child_type == hou.objNodeTypeCategory():
        # create new object
        obj = parent.createNode('geo', 'polydraw_object1')
        obj.moveToGoodPosition()
        sop = obj.createNode('topobuild', 'polydraw1')
        sop.setCurrent(True, True)
    else:
        node = activepane.currentNode()
        if node and node.type().category() == hou.sopNodeTypeCategory() and node.type().name() == 'topobuild':
            sop = node
if sop:
    activepane.enterCurrentNodeState()
else:
    soptoolutils.genericTool(kwargs, 'topobuild', 'polydraw1')]]></script>
  </tool>

  <tool name="sop_deltamush" label="Delta Mush" icon="SOP_deltamush">
    <helpURL>operator:Sop/deltamush</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/deltamush</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Animation/Rigging</toolSubmenu>
    <script scriptType="python"><![CDATA[import toolutils
import soptoolutils

deltamush = soptoolutils.genericTool(kwargs, 'deltamush')
if isinstance(toolutils.activePane(kwargs), hou.SceneViewer):
    deform = soptoolutils.findDeformTypeInputSop(deltamush)
    if deform is not None and len(deform.inputs()) > 0:
        deltamush.setInput(1, deform.inputs()[0])
]]></script>
  </tool>

  <tool name="object_paintcapturelayer" label="Paint Capture Layer" icon="OBJ_STATE_paintcapturelayer">
    <helpURL>operator:Sop/capturelayerpaint</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Animation/Rigging</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericCaptureTool(kwargs, 'capturelayerpaint')]]></script>
  </tool>

  <tool name="generic_delete" label="Delete" icon="SOP_delete">
    <helpURL>operator:Sop/delete</helpURL>
    <script scriptType="python"><![CDATA[import toolutils
import soptoolutils
import doptoolutils


# find out curr context
active_pane = toolutils.activePane(kwargs)
if active_pane is not None and \
    active_pane.type() == hou.paneTabType.ContextViewer:
    active_pane = active_pane.sceneViewer()

if active_pane is None or active_pane.type() != hou.paneTabType.SceneViewer:
    raise hou.Error("The tool was not invoked in the scene viewer.")

# we determine what selection type we should consider (ie, OBJ, SOP,
#  DOP) based on the viewer network path and the child type
scene_viewer = active_pane
child_type   = scene_viewer.pwd().childTypeCategory()

if child_type == hou.objNodeTypeCategory():
    # object context: delete the object nodes
    prompt = toolutils.selectionPrompt(hou.objNodeTypeCategory())
    selected_objects = list(scene_viewer.selectObjects(prompt))
    for object in selected_objects:
        object.destroy()
    scene_viewer.setCurrentState('select')

elif child_type == hou.sopNodeTypeCategory():
    # geometry context: delete the component (points, edges, primitives)
    prompt = toolutils.selectionPrompt(hou.sopNodeTypeCategory())
    # we cannot consume the selection here as the tool we launch will
    # need to use it, i.e., we act as a preliminary select state here.
    selection = scene_viewer.selectGeometry(prompt=prompt,
                                            consume_selections=False)
    type = selection.geometryType()
    if type == hou.geometryType.Primitives \
             or type == hou.geometryType.Points \
             or not selection.primitiveTypes():
        node = soptoolutils.genericTool(kwargs, 'blast')
        node.parm('removegrp').set(True)
    else:
        soptoolutils.genericTool(kwargs, 'dissolve::2.0')
elif child_type == hou.dopNodeTypeCategory():
    # dynamics context: remove object or modifier from simulation
    # obtain the selection and separate objects from modifiers
    prompt = toolutils.selectionPrompt(hou.dopNodeTypeCategory())
    selected_dops = list(scene_viewer.selectDynamics(prompt, 0, True, True))
    dop_objects = []
    dop_modifiers = []
    for dop in selected_dops:
        if isinstance(dop, hou.DopObject):
            dop_objects.append( dop )
        elif isinstance(dop, hou.DopData):
            dop_modifiers.append( dop )
    # call functions that remove the dop data and modifiers from simulation
    if len(dop_objects) > 0:
        doptoolutils.dopObjectsRemoveFromSimulation(dop_objects)
    if len(dop_modifiers) > 0:
        doptoolutils.dopModifiersRemoveFromSimulation(dop_modifiers)

]]></script>
  </tool>

  <tool name="generic_hide" label="Hide" icon="SHELF_hide">
    <helpURL>tool:hide</helpURL>
    <script scriptType="python"><![CDATA[import toolutils

active_pane = toolutils.activePane(kwargs)
prompt = toolutils.selectionPrompt(hou.objNodeTypeCategory())
selected_objects = list(active_pane.selectObjects(prompt))
for object in selected_objects:
    object.setDisplayFlag( False )
toolutils.genericStateTool(kwargs, 'objview')]]></script>
  </tool>

  <tool name="generic_cleartexcache" label="Clear Texture Cache" icon="SHELF_clear_texture_cache">
    <helpURL>tool:cleartexcache</helpURL>
    <script scriptType="hscript"><![CDATA[texcache -c]]></script>
  </tool>

  <tool name="sop_fuse::2.0" label="Fuse" icon="SOP_fuse">
    <helpURL>operator:Sop/fuse#fuse</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils
kwargs['parms'] = { 'consolidatesnappedpoints': True }
soptoolutils.genericTool(kwargs, 'fuse::2.0')
]]></script>
  </tool>

  <tool name="geometry_snap" label="Snap" icon="SOP_fuse">
    <helpURL>operator:Sop/fuse#snap</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils
kwargs['parms'] = { 'consolidatesnappedpoints': False }
soptoolutils.genericTool(kwargs, 'fuse::2.0', 'snap1')
]]></script>
  </tool>

  <tool name="sop_uvproject" label="UV Project" icon="SOP_uvproject">
    <helpURL>operator:Sop/uvproject</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/uvproject</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Texturing/UV</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils

sop = soptoolutils.addUVTool(kwargs, 'uvproject', 'uvattrib')
# compute the geometry bounding box and use it for the projection plane
sop.parm('initbbox').pressButton()
]]></script>
  </tool>

  <tool name="sop_uvfuse" label="UV Fuse" icon="SOP_uvfuse">
    <helpURL>operator:Sop/uvfuse</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/uvfuse</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Texturing/UV</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils

sop = soptoolutils.addUVTool(kwargs, 'uvfuse', 'uvattrib')
]]></script>
  </tool>

  <tool name="sop_texture" label="UV Texture" icon="SOP_texture">
    <helpURL>operator:Sop/texture</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/texture</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Texturing/UV</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils

sop = soptoolutils.addUVTool(kwargs, 'texture', 'uvattrib')
]]></script>
  </tool>

  <tool name="sop_uvpelt::2.0" label="UV Pelt" icon="SOP_uvpelt">
    <helpURL>operator:Sop/uvpelt?version=2.0</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/uvpelt</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Texturing/UV</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils

sop = soptoolutils.addUVTool(kwargs, 'uvpelt::2.0', 'uvattrib')
]]></script>
  </tool>

  <tool name="sop_uvunwrap" label="UV Unwrap" icon="SOP_uvunwrap">
    <helpURL>operator:Sop/uvunwrap</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/uvunwrap</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Texturing/UV</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils

sop = soptoolutils.addUVTool(kwargs, 'uvunwrap', 'uvattrib')
]]></script>
  </tool>

  <tool name="sop_uvtransform::2.0" label="UV Transform" icon="SOP_uvtransform">
    <helpURL>operator:Sop/uvtransform?version=2.0</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/uvtransform::2.0</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Texturing/UV</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils

sop = soptoolutils.addUVTool(kwargs, 'uvtransform::2.0', 'uvattrib')
]]></script>
  </tool>

  <tool name="sop_uvedit" label="UV Edit" icon="SOP_uvedit">
    <helpURL>operator:Sop/uvedit</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/uvedit</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Texturing/UV</toolSubmenu>
    <script scriptType="python"><![CDATA[
import soptoolutils

sop = soptoolutils.addUVTool(kwargs, 'uvedit', 'uvattrib')
]]></script>
  </tool>

  <tool name="geometry_file" label="File" icon="SOP_file">
    <helpURL>operator:Sop/file</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>File IO/Import</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.chooseAndOpenGeoFile(kwargs, True)]]></script>
  </tool>

  <tool name="object_jiggleobject" label="Jiggle" icon="CHOP_jiggle">
    <helpURL>tool:jiggleobject</helpURL>
    <script scriptType="python"><![CDATA[import toolutils
import choptoolutils

def addJiggle(input_chop, source_name):
    chop = input_chop.parent().createNode("jiggle", source_name + "_jiggle1")
    chop.setInput(0, input_chop)
    chop.moveToGoodPosition()
    return chop

scene_viewer = toolutils.sceneViewer()

targets = list(scene_viewer.selectObjects(
    prompt = "Select object to jiggle and press Enter to complete.",
    allow_multisel = False))
if len(targets) == 0:
    raise hou.Error("Nothing was selected.")
target = targets[0]
target.setSelected(False)

sources = list(scene_viewer.selectObjects(
    prompt = "Now select object to follow, if any, and press Enter to complete.",
    allow_multisel = False))
source = None
if len(sources) > 0:
    source = sources[0]
    source.setSelected(False)

(obj_chop, jiggle_chop, output_chop) = choptoolutils.modifyObjectTool(
    'jiggle', source, target, addJiggle)

output_chop.setExportFlag(True)

choptoolutils.visualizeParmEffect(jiggle_chop, output_chop)]]></script>
  </tool>

  <tool name="object_lagobject" label="Lag" icon="CHOP_lag">
    <helpURL>tool:lagobject</helpURL>
    <script scriptType="python"><![CDATA[import toolutils
import choptoolutils

def addLag(input_chop, source_name):
    lag_chop = input_chop.parent().createNode("lag", source_name + "_lag1")
    lag_chop.setInput(0, input_chop)
    lag_chop.moveToGoodPosition()
    lag_chop.parm("scope").set("t[xyz]")
    return lag_chop

scene_viewer = toolutils.sceneViewer()

targets = list(scene_viewer.selectObjects(
    prompt = "Select object to lag and press Enter to complete.",
    allow_multisel = False))
if len(targets) == 0:
    raise hou.Error("Nothing was selected.")
target = targets[0]
target.setSelected(False)

sources = list(scene_viewer.selectObjects(
    prompt = "Now select object to follow, if any, and press Enter to complete.",
    allow_multisel = False))
source = None
if len(sources) > 0:
    source = sources[0]
    source.setSelected(False)

(obj_chop, lag_chop, output_chop) = choptoolutils.modifyObjectTool(
    'lag', source, target, addLag)

output_chop.setExportFlag(True)

choptoolutils.visualizeParmEffect(lag_chop, output_chop)]]></script>
  </tool>

  <tool name="geometry_paintcolorvolume" label="Volume Paint Color" icon="SOP_paintcolorvolume">
    <helpURL>operator:Sop/paintcolorvolume</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Volume</toolSubmenu>
    <script scriptType="python"><![CDATA[
import stroketoolutils

kwargs['type'] = "color"
stroketoolutils.strokeSource(kwargs)
]]></script>
  </tool>

  <tool name="geometry_paintfogvolume" label="Volume Paint Fog" icon="SOP_paintfogvolume">
    <helpURL>operator:Sop/paintfogvolume</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Volume</toolSubmenu>
    <script scriptType="python"><![CDATA[
import stroketoolutils

kwargs['type'] = "fog"
stroketoolutils.strokeSource(kwargs)
]]></script>
  </tool>

  <tool name="quickshapes" label="Quick Shapes" icon="SHELF_quick_shapes">
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Primitive</toolSubmenu>
    <script scriptType="python"><![CDATA[import toolutils

scene_viewer = toolutils.sceneViewer()
network = scene_viewer.pwd()
if network.childTypeCategory() == hou.lopNodeTypeCategory():
    scene_viewer.setCurrentState("sidefx_quickshapes_lop")
else:
    scene_viewer.setCurrentState("sidefx_quickshapes")]]></script>
  </tool>

  <tool name="object_groom" label="Groom" icon="FUR_guidegroom">
    <helpURL>tool:groom_groom</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.createFurAndStartGrooming(kwargs)]]></script>
  </tool>

  <tool name="object_groom_addfur" label="Add Fur" icon="FUR_add_fur">
    <helpURL>tool:groom_addfur</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.addFurTool(kwargs)]]></script>
  </tool>

  <tool name="object_groom_guidegroomempty" label="Create Empty Guide Groom" icon="FUR_guidegroom">
    <helpURL>tool:groom_emptyguidegroom</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.guideGroomEmptyTool(kwargs)]]></script>
  </tool>

  <tool name="object_groom_guidegroom" label="Create Guides" icon="FUR_guidegroom">
    <helpURL>tool:groom_guidegroom</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.guideGroomTool(kwargs)]]></script>
  </tool>

  <tool name="object_groom_groommerge" label="Merge Groom Objects" icon="FUR_groommerge">
    <helpURL>tool:groom_groommerge</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.groomMergeTool(kwargs)]]></script>
  </tool>

  <tool name="object_groom_animateguides" label="Deform Guides" icon="FUR_animate">
    <helpURL>tool:groom_animateguides</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.animateGuidesTool(kwargs)]]></script>
  </tool>

  <tool name="object_groom_simguides" label="Simulate Guides" icon="FUR_add_dynamics">
    <helpURL>tool:groom_simguides</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.simGuidesTool(kwargs)]]></script>
  </tool>

  <tool name="object_groom_hairgen" label="Generate Hair" icon="FUR_hairgen">
    <helpURL>tool:groom_hairgen</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.hairGenTool(kwargs)]]></script>
  </tool>

  <tool name="object_groom_haircardgen" label="Generate Hair Cards" icon="FUR_haircardgen">
    <helpURL>tool:groom_haircardgen</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.hairCardGenTool(kwargs)]]></script>
  </tool>

  <tool name="object_groom_togglehairdisplay" label="Toggle Display" icon="FUR_toggle_display">
    <helpURL>tool:groom_togglehairdisplay</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.toggleHairDisplayTool(kwargs)]]></script>
  </tool>

  <tool name="object_groom_isolateparts" label="Isolate Groom Parts" icon="FUR_isolate_parts">
    <helpURL>tool:groom_isolateparts</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.isolateGroomParts(kwargs)]]></script>
  </tool>

  <tool name="object_groom_haircardtexture" label="Hair Card Texture" icon="FUR_haircardtex">
    <helpURL>tool:groom_haircardtexture</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.hairCardTextureTool(kwargs)]]></script>
  </tool>

  <tool name="sop_groom_reguide" label="Reguide" icon="FUR_reguide">
    <helpURL>tool:reguide</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.reguideTool(kwargs)]]></script>
  </tool>

  <tool name="sop_groom_drawpartingline" label="Part Guides" icon="FUR_addparting">
    <helpURL>tool:drawpartingline</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.drawPartingLineTool(kwargs)]]></script>
  </tool>

  <tool name="sop_groom_guideinit" label="Initialize Guides" icon="FUR_initialize_guides">
    <helpURL>tool:sop_groom_guideinit</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.guideInitTool(kwargs)]]></script>
  </tool>

  <tool name="sop_groom_guideprocess_setdir" label="Set Guide Direction" icon="FUR_comb">
    <helpURL>tool:sop_groom_guideprocess_setdir</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.guideProcessTool(kwargs, 'setdirvec')]]></script>
  </tool>

  <tool name="sop_groom_guideprocess_length" label="Set Guide Length" icon="FUR_paint_length">
    <helpURL>tool:sop_groom_guideprocess_length</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.guideProcessTool(kwargs, 'setlength')]]></script>
  </tool>

  <tool name="sop_groom_guideprocess_lift" label="Lift Guides" icon="FUR_lift_hair">
    <helpURL>tool:sop_groom_guideprocess_lift</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.guideProcessTool(kwargs, 'setlift')]]></script>
  </tool>

  <tool name="sop_groom_guideprocess_bend" label="Bend Guides" icon="FUR_orientation">
    <helpURL>tool:sop_groom_guideprocess_bend</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.guideProcessTool(kwargs, 'bend')]]></script>
  </tool>

  <tool name="sop_groom_guideprocess_straighten" label="Straighten Guides" icon="FUR_paint_straighten">
    <helpURL>tool:sop_groom_guideprocess_straighten</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.guideProcessTool(kwargs, 'straighten')]]></script>
  </tool>

  <tool name="sop_groom_guideprocess_smooth" label="Smooth Guides" icon="FUR_smooth">
    <helpURL>tool:sop_groom_guideprocess_smooth</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.guideProcessTool(kwargs, 'smooth')]]></script>
  </tool>

  <tool name="sop_groom_guideprocess_frizz" label="Frizz Guides" icon="FUR_paint_frizz">
    <helpURL>tool:sop_groom_guideprocess_frizz</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.guideProcessTool(kwargs, 'frizz')]]></script>
  </tool>

  <tool name="sop_groom_hairclump" label="Clump Guides" icon="FUR_paint_clumping">
    <helpURL>tool:sop_groom_hairclump</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.clumpHairTool(kwargs)]]></script>
  </tool>

  <tool name="sop_groom_whitehair" label="Add White Hairs" icon="FUR_paint_white_density">
    <helpURL>tool:sop_groom_whitehair</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.whiteHairTool(kwargs)]]></script>
  </tool>

  <tool name="sop_groom_curveadvect" label="Curve Advect" icon="SOP_guideadvect">
    <helpURL>tool:sop_groom_curveadvect</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Character FX/Hair and Fur</toolSubmenu>
    <script scriptType="python"><![CDATA[
import furtoolutils
furtoolutils.curveAdvectTool(kwargs)]]></script>
  </tool>

  <tool name="geometry_paintsdfvolume" label="Volume Paint SDF" icon="SOP_paintsdfvolume">
    <helpURL>operator:Sop/paintsdfvolume</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Volume</toolSubmenu>
    <script scriptType="python"><![CDATA[
import stroketoolutils

kwargs['type'] = "sdf"
stroketoolutils.strokeSource(kwargs)
]]></script>
  </tool>

  <tool name="geometry_drawcurve" label="Draw Curve" icon="SOP_drawcurve">
    <helpURL>operator:Sop/drawcurve</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Curves</toolSubmenu>
    <script scriptType="python"><![CDATA[
import stroketoolutils

kwargs['type'] = "curve"
stroketoolutils.strokeSource(kwargs)
]]></script>
  </tool>

  <tool name="geometry_spraypaint" label="Spray Paint" icon="SOP_spraypaint">
    <helpURL>operator:Sop/spraypaint</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Points</toolSubmenu>
    <script scriptType="python"><![CDATA[
import stroketoolutils

kwargs['type'] = "spraypaint"
stroketoolutils.strokeSource(kwargs)
]]></script>
  </tool>

  <tool name="geometry_volumerasterizepoints" label="Fog Points" icon="SOP_volumerasterizepoints">
    <helpURL>operator:Sop/volumerasterizepoints</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Volume</toolSubmenu>
    <script scriptType="python"><![CDATA[
import stroketoolutils

kwargs['type'] = "points"
stroketoolutils.volumerasterizeSource(kwargs)
]]></script>
  </tool>

  <tool name="geometry_volumerasterizeparticles" label="Fog Particles" icon="SOP_volumerasterizeparticles">
    <helpURL>operator:Sop/volumerasterizeparticles</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Volume</toolSubmenu>
    <script scriptType="python"><![CDATA[
import stroketoolutils

kwargs['type'] = "particles"
stroketoolutils.volumerasterizeSource(kwargs)
]]></script>
  </tool>

  <tool name="geometry_volumerasterizecurve" label="Fog Curve" icon="SOP_volumerasterizecurve">
    <helpURL>operator:Sop/volumerasterizecurve</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Volume</toolSubmenu>
    <script scriptType="python"><![CDATA[
import stroketoolutils

kwargs['type'] = "curve"
stroketoolutils.volumerasterizeSource(kwargs)
]]></script>
  </tool>

  <tool name="geometry_vdbfrompolygons" label="SDF Polys" icon="SOP_vdbfrompolygons">
    <helpURL>operator:Sop/vdbfrompolygons</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Volume/VDB</toolSubmenu>
    <script scriptType="python"><![CDATA[
import volumetoolutils

kwargs['volumetype'] = "vdb"
kwargs['optype'] = "frompolygons"

volumetoolutils.volumeSource(kwargs)
]]></script>
  </tool>

  <tool name="geometry_vdbfromparticles" label="SDF Particles" icon="SOP_vdbfromparticles">
    <helpURL>operator:Sop/vdbfromparticles</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Volume/VDB</toolSubmenu>
    <script scriptType="python"><![CDATA[
import volumetoolutils

kwargs['volumetype'] = "vdb"
kwargs['optype'] = "fromparticles"

volumetoolutils.volumeSource(kwargs)
]]></script>
  </tool>

  <tool name="geometry_convertvdb" label="Convert VDB" icon="SOP_convertvdb">
    <helpURL>operator:Sop/convertvdb</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Convert</toolSubmenu>
    <script scriptType="python"><![CDATA[

import volumetoolutils

kwargs['volumetype'] = "vdb"
kwargs['optype'] = "convert"

volumetoolutils.volumeSource(kwargs)
]]></script>
  </tool>

  <tool name="object_editcaptureblend" label="Edit Capture Blends" icon="OBJ_STATE_editcaptureblend">
    <helpURL>tool:editcaptureblends</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Animation/Rigging</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.customStateTool(kwargs, 'editcaptureblend')]]></script>
  </tool>

  <tool name="object_editcaptureweight" label="Edit Capture Weights" icon="OBJ_STATE_editcaptureweight">
    <helpURL>tool:editcaptureweights</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Animation/Rigging</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.customStateTool(kwargs, 'editcaptureweight')]]></script>
  </tool>

  <tool name="object_mirrorcapture" label="Mirror Capture Weights" icon="OBJ_STATE_mirrorcapture">
    <helpURL>tool:mirrorcaptureweights</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Animation/Rigging</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.customStateTool(kwargs, 'mirrorcapture')]]></script>
  </tool>

  <tool name="object_editcaptureregion" label="Edit Capture Regions" icon="OBJ_STATE_editcaptureregion">
    <helpURL>tool:editcaptureregions</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Animation/Rigging</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.customStateTool(kwargs, 'editcaptureregion')]]></script>
  </tool>

  <tool name="object_constraintparentblend" label="Parent Blend" icon="SHELF_parent">
    <helpURL>tool:constraintparentblend</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Constraints</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.constraintparentblendStateTool(kwargs)]]></script>
  </tool>

  <tool name="object_constraintblend" label="Blend" icon="OBJ_blend">
    <helpURL>tool:constraintblend</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Constraints</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.constraintblendStateTool(kwargs)]]></script>
  </tool>

  <tool name="object_constraintlookat" label="Look At" icon="SHELF_lookat">
    <helpURL>tool:constraintlookat</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Constraints</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils
import loptoolutils
import toolutils

cwd = toolutils.sceneViewer().pwd()
mod = loptoolutils if cwd.childTypeCategory() == hou.lopNodeTypeCategory() else objecttoolutils
mod.constraintlookatStateTool(kwargs)]]></script>
  </tool>

  <tool name="object_constraintpath" label="Follow Path" icon="SHELF_followpath">
    <helpURL>tool:constraintpath</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Constraints</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils
import loptoolutils
import toolutils

cwd = toolutils.sceneViewer().pwd()
mod = loptoolutils if cwd.childTypeCategory() == hou.lopNodeTypeCategory() else objecttoolutils
mod.constraintpathStateTool(kwargs)]]></script>
  </tool>

  <tool name="object_constraintsurface" label="Surface" icon="OBJ_sticky">
    <helpURL>tool:constraintsurface</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Constraints</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils
import loptoolutils
import toolutils

cwd = toolutils.sceneViewer().pwd()
mod = loptoolutils if cwd.childTypeCategory() == hou.lopNodeTypeCategory() else objecttoolutils
mod.constraintsurfaceStateTool(kwargs)]]></script>
  </tool>

  <tool name="object_constraintpoints" label="Points" icon="OBJ_rivet">
    <helpURL>tool:constraintpoints</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Constraints</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils
import loptoolutils
import toolutils

cwd = toolutils.sceneViewer().pwd()
mod = loptoolutils if cwd.childTypeCategory() == hou.lopNodeTypeCategory() else objecttoolutils
mod.constraintpointsStateTool(kwargs)]]></script>
  </tool>

  <tool name="object_constraintgamepad" label="Gamepad" icon="CHOP_gamepad">
    <helpURL>tool:constraintgamepad</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Constraints</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.constraintgamepadStateTool(kwargs)]]></script>
  </tool>

  <tool name="object_constrainttransform" label="Transform Constraint" icon="CHOP_constrainttransform">
    <helpURL>tool:transformconstraint</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Constraints</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils
import loptoolutils
import toolutils

cwd = toolutils.sceneViewer().pwd()
if cwd.childTypeCategory() == hou.lopNodeTypeCategory():
    loptoolutils.constraintparentStateTool(kwargs)
else:
    objecttoolutils.constrainttransformStateTool(kwargs)]]></script>
  </tool>

  <tool name="object_constraintdelete" label="Delete Constraint" icon="SOP_delete">
    <helpURL>tool:constraintdelete</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Constraints</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils
objecttoolutils.constraintdeleteStateTool(kwargs)]]></script>
  </tool>

  <tool name="object_constrainttoggle" label="Toggle Constraint" icon="SHELF_constraint_toggle">
    <helpURL>tool:constrainttoggle</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Constraints</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils
objecttoolutils.constrainttoggleStateTool(kwargs)]]></script>
  </tool>

  <tool name="object_constraintbake" label="Bake Constraint" icon="SHELF_constraint_bake">
    <helpURL>tool:bakeconstraints</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Constraints</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils
objecttoolutils.constraintbakeStateTool(kwargs)]]></script>
  </tool>

  <tool name="object_bakeanimation" label="Bake Animation" icon="ROP_bake_animation">
    <helpURL>operator:Driver/bake_animation</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Constraints</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils
objecttoolutils.bakeanimationStateTool(kwargs)]]></script>
  </tool>

  <tool name="rigging_ikfromobjects" label="IK from Objects" icon="OBJ_autorig_blank">
    <helpURL>tool:rigging_ikfromobjects</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Animation/Rigging</toolSubmenu>
    <script scriptType="python"><![CDATA[
from rigtoolutils import iktwisttool
iktwisttool.invokeTool(kwargs)
]]></script>
  </tool>

  <tool name="rigging_ikfrombones" label="IK from Bones" icon="OBJ_autorig_blank">
    <helpURL>tool:rigging_ikfrombones</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Animation/Rigging</toolSubmenu>
    <script scriptType="python"><![CDATA[
from rigtoolutils import boneiktwisttool
boneiktwisttool.invokeTool(kwargs)
]]></script>
  </tool>

  <tool name="sop_polybevel::3.0" label="PolyBevel" icon="SOP_polybevel">
    <helpURL>operator:Sop/polybevel?version=3.0</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/polybevel::3.0</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
soptoolutils.addPolyBevelTool(kwargs)
]]></script>
  </tool>

  <tool name="sop_uvflatten::3.0" label="UV Flatten" icon="SOP_uvflatten">
    <helpURL>operator:Sop/uvflatten?version=3.0</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/uvflatten::3.0</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Texturing/UV</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
soptoolutils.addUVFlattenTool(kwargs)
]]></script>
  </tool>

  <tool name="object_parent" label="Parent" icon="SHELF_parent">
    <helpURL>operator:obj_state/parent</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Animation/Rigging</toolSubmenu>
    <toolSubmenu>Parenting</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.customStateTool(kwargs, 'parent')]]></script>
  </tool>

  <tool name="object_blendpose" label="BlendPose" icon="OBJ_STATE_blendpose">
    <helpURL>operator:obj_state/blendpose</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Parenting</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.customStateTool(kwargs, 'blendpose')]]></script>
  </tool>

  <tool name="object_aligncapturepose" label="Align Capture Pose" icon="OBJ_STATE_aligncapturepose">
    <helpURL>operator:obj_state/aligncapturepose</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Animation/Rigging</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.customStateTool(kwargs, 'aligncapturepose')]]></script>
  </tool>

  <tool name="object_bones" label="Bones" icon="OBJ_STATE_bones">
    <helpURL>operator:obj_state/bones</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Animation/Rigging</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.customStateTool(kwargs, 'bones')]]></script>
  </tool>

  <tool name="object_bonesfromcurve" label="Bones from Curve" icon="OBJ_STATE_bonesfromcurve">
    <helpURL>operator:obj_state/bonesfromcurve</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Animation/Rigging</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.customStateTool(kwargs, 'bonesfromcurve')]]></script>
  </tool>

  <tool name="object_pose" label="Pose" icon="OBJ_STATE_pose">
    <helpURL>operator:obj_state/pose</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Animation/Rigging</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.customStateTool(kwargs, 'pose')]]></script>
  </tool>

  <tool name="object_capturegeometry" label="Capture Geometry" icon="SOP_capture">
    <helpURL>operator:obj_state/capturegeometry</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Animation/Rigging</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.customStateTool(kwargs, 'capturegeometry')]]></script>
  </tool>

  <tool name="object_path" label="Path" icon="OBJ_STATE_path">
    <helpURL>operator:Object/path</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Object/path</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Utility</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.customStateTool(kwargs, 'path')]]></script>
  </tool>

  <tool name="object_morph" label="Morph" icon="SOP_blendshapes">
    <helpURL>operator:obj_state/morph</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Animation/Rigging</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.customStateTool(kwargs, 'morph')]]></script>
  </tool>

  <tool name="object_null" label="Null" icon="OBJ_null">
    <helpURL>operator:Object/null</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Object/null</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Utility</toolSubmenu>
    <script scriptType="python"><![CDATA[import objecttoolutils

kwargs['bbox'] = hou.BoundingBox(-0.5, -0.5, -0.5, 0.5, 0.5, 0.5)
objecttoolutils.genericTool(kwargs, 'null')]]></script>
  </tool>

  <tool name="sop_comb" label="Comb" icon="SOP_comb">
    <helpURL>operator:Sop/comb</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/comb</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Attribute</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.customStateTool(kwargs, 'comb')]]></script>
  </tool>

  <tool name="sop_uvbrush" label="UV Brush" icon="SOP_uvbrush">
    <helpURL>operator:Sop/uvbrush</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/uvbrush</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Texturing/UV</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.customStateTool(kwargs, 'uvbrush')]]></script>
  </tool>

  <tool name="sop_edit" label="Edit" icon="SOP_edit">
    <helpURL>operator:Sop/edit</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/edit</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Deform</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.customStateTool(kwargs, 'edit')]]></script>
  </tool>

  <tool name="sop_polybridge" label="PolyBridge" icon="SOP_polybridge">
    <helpURL>operator:Sop/polybridge</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/polybridge</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.customStateTool(kwargs, 'polybridge')]]></script>
  </tool>

  <tool name="sop_polyextrude::2.0" label="PolyExtrude" icon="SOP_polyextrude">
    <helpURL>operator:Sop/polyextrude?version=2.0</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/polyextrude::2.0</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.customStateTool(kwargs, 'polyextrude::2.0')]]></script>
  </tool>

  <tool name="sop_lattice" label="Lattice" icon="SOP_lattice">
    <helpURL>operator:Sop/lattice</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/lattice</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Deform</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.customStateTool(kwargs, 'lattice')]]></script>
  </tool>

  <tool name="sop_polysplit::2.0" label="PolySplit" icon="SOP_polysplit">
    <helpURL>operator:Sop/polysplit?version=2.0</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/polysplit::2.0</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Edges</toolSubmenu>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.customStateTool(kwargs, 'polysplit::2.0')]]></script>
  </tool>

  <tool name="sop_edgeloop" label="Edge Loop" icon="SHELF_edgeloop">
    <helpURL>operator:sop_state/edgeloop</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.customStateTool(kwargs, 'edgeloop')]]></script>
  </tool>

  <tool name="sop_uvlayout::3.0" label="UV Layout" icon="SOP_uvlayout">
    <helpURL>operator:Sop/uvlayout?version=3.0</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/uvlayout::3.0</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Texturing/UV</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.customStateTool(kwargs, 'uvlayout::3.0')]]></script>
  </tool>

  <tool name="sop_sweep::2.0" label="Sweep" icon="SOP_sweep-2.0">
    <helpURL>operator:Sop/sweep?version=2.0</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/sweep::2.0</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'sweep::2.0')]]></script>
  </tool>

  <tool name="sop_creep" label="Creep" icon="SOP_creep">
    <helpURL>operator:Sop/creep</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/creep</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/NURBS</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'creep')]]></script>
  </tool>

  <tool name="sop_carve" label="Carve" icon="SOP_carve">
    <helpURL>operator:Sop/carve</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/carve</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/NURBS</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'carve')]]></script>
  </tool>

  <tool name="sop_scatter::2.0" label="Scatter" icon="SOP_scatter-2.0">
    <helpURL>operator:Sop/scatter?version=2.0</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/scatter::2.0</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Copying</toolSubmenu>
    <toolSubmenu>Geometry/Points</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'scatter::2.0')]]></script>
  </tool>

  <tool name="sop_facet" label="Facet" icon="SOP_facet">
    <helpURL>operator:Sop/facet</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/facet</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'facet')]]></script>
  </tool>

  <tool name="sop_dissolve::2.0" label="Dissolve" icon="SOP_dissolve-2.0">
    <helpURL>operator:Sop/dissolve?version=2.0</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/dissolve::2.0</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'dissolve::2.0')]]></script>
  </tool>

  <tool name="sop_bulge" label="Bulge" icon="SOP_bulge">
    <helpURL>operator:Sop/bulge</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/bulge</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Metaball</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'bulge')]]></script>
  </tool>

  <tool name="sop_lsystem" label="L-System" icon="SOP_lsystem">
    <helpURL>operator:Sop/lsystem</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Primitive</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

if hou.ui.orientationUpAxis() == hou.orientUpAxis.Z:
    kwargs['bbox'] = hou.BoundingBox(-0.5059784650802612, -0.5457153916358948, 0.0, 0.39274096488952637, 0.39255478978157043, 0.9793723821640015)
else:
    kwargs['bbox'] = hou.BoundingBox(-0.5059784650802612, 0.0, -0.5457153916358948, 0.39274096488952637, 0.9793723821640015, 0.39255478978157043)
lsystem = soptoolutils.genericTool(kwargs, 'lsystem')

if hou.ui.orientationUpAxis() == hou.orientUpAxis.Z:
    parm = lsystem.parm('premise')
    if not lsystem.type().hasPermanentUserDefaults() and not parm.hasTemporaryDefaults():
        parm.set('^(90)' + parm.evalAsString())]]></script>
  </tool>

  <tool name="sop_polyexpand2d" label="PolyExpand2D" icon="SOP_polyexpand2d">
    <helpURL>operator:Sop/polyexpand2d</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/polyexpand2d</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'polyexpand2d')]]></script>
  </tool>

  <tool name="sop_skin" label="Skin" icon="SOP_skin">
    <helpURL>operator:Sop/skin</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/skin</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/NURBS</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'skin')]]></script>
  </tool>

  <tool name="sop_visibility" label="Visibility" icon="SOP_visibility">
    <helpURL>operator:Sop/visibility</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/visibility</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Attribute</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'visibility')]]></script>
  </tool>

  <tool name="sop_edgecollapse" label="Edge Collapse" icon="SOP_edgecollapse">
    <helpURL>operator:Sop/edgecollapse</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/edgecollapse</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Edges</toolSubmenu>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'edgecollapse', allow_obj_sel=False)]]></script>
  </tool>

  <tool name="sop_polyreduce::2.0" label="PolyReduce" icon="SOP_polyreduce-2.0">
    <helpURL>operator:Sop/polyreduce?version=2.0</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/polyreduce::2.0</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'polyreduce::2.0')]]></script>
  </tool>

  <tool name="sop_font" label="Font" icon="SOP_font">
    <helpURL>operator:Sop/font</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Primitive</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

kwargs['bbox'] = hou.BoundingBox(-1.877750039100647, -0.3700000047683716, 0.0, 1.8777501583099365, 0.3620000183582306, 0.0)
soptoolutils.genericTool(kwargs, 'font')]]></script>
  </tool>

  <tool name="sop_rails" label="Rails" icon="SOP_rails">
    <helpURL>operator:Sop/rails</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/rails</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'rails')]]></script>
  </tool>

  <tool name="sop_refine" label="Refine" icon="SOP_refine">
    <helpURL>operator:Sop/refine</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/refine</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/NURBS</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'refine', allow_obj_sel=False)]]></script>
  </tool>

  <tool name="sop_subdivide" label="Subdivide" icon="SOP_subdivide">
    <helpURL>operator:Sop/subdivide</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/subdivide</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'subdivide')]]></script>
  </tool>

  <tool name="sop_fractal" label="Fractal" icon="SOP_fractal">
    <helpURL>operator:Sop/fractal</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/fractal</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Deform</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
from soptoolutils import OrientInfo

soptoolutils.genericTool(kwargs, 'fractal', orient=OrientInfo('dir'))]]></script>
  </tool>

  <tool name="sop_ray" label="Ray" icon="SOP_ray">
    <helpURL>operator:Sop/ray</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/ray</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Deform</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'ray')]]></script>
  </tool>

  <tool name="sop_edgedivide" label="Edge Divide" icon="SOP_edgedivide">
    <helpURL>operator:Sop/edgedivide</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/edgedivide</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Edges</toolSubmenu>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'edgedivide', allow_obj_sel=False)]]></script>
  </tool>

  <tool name="sop_edgecusp" label="Edge Cusp" icon="SOP_edgecusp">
    <helpURL>operator:Sop/edgecusp</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/edgecusp</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Edges</toolSubmenu>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'edgecusp', allow_obj_sel=False)]]></script>
  </tool>

  <tool name="sop_uvquickshade" label="UV Quick Shade" icon="SOP_uvquickshade">
    <helpURL>operator:Sop/uvquickshade</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/uvquickshade</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Texturing</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'uvquickshade', allow_obj_sel=False)]]></script>
  </tool>

  <tool name="sop_convert" label="Convert" icon="SOP_convert">
    <helpURL>operator:Sop/convert</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/convert</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Convert</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'convert', allow_obj_sel=False)]]></script>
  </tool>

  <tool name="sop_polyfill" label="PolyFill" icon="SOP_polyfill">
    <helpURL>operator:Sop/polyfill</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/polyfill</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'polyfill')]]></script>
  </tool>

  <tool name="sop_edgeflip" label="Edge Flip" icon="SOP_edgeflip">
    <helpURL>operator:Sop/edgeflip</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/edgeflip</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Edges</toolSubmenu>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'edgeflip', allow_obj_sel=False)]]></script>
  </tool>

  <tool name="sop_reverse" label="Reverse" icon="SOP_reverse">
    <helpURL>operator:Sop/reverse</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/reverse</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'reverse', allow_obj_sel=False)]]></script>
  </tool>

  <tool name="ViewportFlipbook0" label="ViewportFlipbook" icon="$PLAB/icons/ViewportFlipbook.png">
    <script scriptType="python"><![CDATA[import hou
import os
import re
import sys
import subprocess
import toolutils
from PySide2 import QtWidgets, QtCore


# --------- Utilities --------- #

def get_ffmpeg_bin():
    PLAB = os.getenv("PLAB")
    if not PLAB:
        raise hou.Error("PLAB environment variable not set.")
    ffmpeg = os.path.join(PLAB, "ffmpeg", "bin", "ffmpeg.exe" if os.name == "nt" else "ffmpeg")
    if not os.path.exists(ffmpeg):
        raise hou.Error(f"FFmpeg not found:\n{ffmpeg}")
    return ffmpeg


def find_next_version(base_folder):
    if not os.path.exists(base_folder):
        return "V001"
    versions = [v for v in os.listdir(base_folder) if re.match(r"V\d{3}", v)]
    if not versions:
        return "V001"
    versions.sort()
    last = versions[-1]
    next_num = int(last[1:]) + 1
    return f"V{next_num:03}"


# --------- Dialog --------- #

class FlipbookDialog(QtWidgets.QDialog):
    def __init__(self, start="1001", end="1100", version="V001", parent=None):
        super(FlipbookDialog, self).__init__(parent)
        self.setWindowTitle("Viewport Flipbook Settings")
        self.setFixedWidth(300)

        layout = QtWidgets.QFormLayout(self)

        self.start_edit = QtWidgets.QLineEdit(start)
        self.end_edit = QtWidgets.QLineEdit(end)
        self.version_edit = QtWidgets.QLineEdit(version)
        self.open_checkbox = QtWidgets.QCheckBox("Open MP4 After Render")
        self.open_checkbox.setChecked(False)

        layout.addRow("Start Frame:", self.start_edit)
        layout.addRow("End Frame:", self.end_edit)
        layout.addRow("Version:", self.version_edit)
        layout.addRow("", self.open_checkbox)

        btn_layout = QtWidgets.QHBoxLayout()
        self.ok_btn = QtWidgets.QPushButton("Flipbook")
        self.cancel_btn = QtWidgets.QPushButton("Cancel")
        btn_layout.addWidget(self.ok_btn)
        btn_layout.addWidget(self.cancel_btn)
        layout.addRow(btn_layout)

        self.ok_btn.clicked.connect(self.validate_and_accept)
        self.cancel_btn.clicked.connect(self.reject)

    def validate_and_accept(self):
        if not (self.start_edit.text().isdigit() and self.end_edit.text().isdigit()):
            QtWidgets.QMessageBox.warning(self, "Invalid Input", "Start and End must be integers.")
            return
        if not self.version_edit.text().strip():
            QtWidgets.QMessageBox.warning(self, "Invalid Input", "Version cannot be empty.")
            return
        self.accept()

    def get_values(self):
        return (
            int(self.start_edit.text()),
            int(self.end_edit.text()),
            self.version_edit.text().strip(),
            self.open_checkbox.isChecked()
        )


# --------- Main --------- #

def main():
    # Prepare context
    hipfile = hou.hipFile.path()
    if not hipfile:
        raise hou.Error("Please save your scene before flipbooking.")
    hip_name = os.path.splitext(os.path.basename(hipfile))[0]
    hip_dir = os.path.dirname(hipfile)
    flipbook_dir = os.path.join(hip_dir, "Flipbooks")
    version_guess = find_next_version(flipbook_dir)

    start, end = hou.playbar.frameRange()
    default_start = str(int(start))
    default_end = str(int(end))

    # Create dialog
    app = QtWidgets.QApplication.instance()
    if not app:
        app = QtWidgets.QApplication([])  # Only needed outside Houdini

    dialog = FlipbookDialog(start=default_start, end=default_end, version=version_guess)
    if not dialog.exec_():
        return  # Cancelled

    start_frame, end_frame, version_str, open_after = dialog.get_values()

    # Scene Viewer & Camera
    viewer = toolutils.sceneViewer()
    viewport = viewer.curViewport()
    camera = viewport.camera()
    if not camera:
        raise hou.Error("Please lock a camera to the viewport.")

    resx = int(camera.parm("resx").eval())
    resy = int(camera.parm("resy").eval())

    # Setup output
    version_folder = os.path.join(flipbook_dir, version_str)
    os.makedirs(version_folder, exist_ok=True)
    image_pattern = os.path.join(version_folder, f"{hip_name}_{version_str}.$F4.exr")

    # Flipbook settings
    settings = viewer.flipbookSettings()
    settings.stash()
    settings.output(image_pattern)
    settings.frameRange((start_frame, end_frame))
    settings.useResolution(True)
    settings.resolution((resx, resy))

    settings.useMotionBlur(False)
    settings.cropOutMaskOverlay(True)

    viewer.flipbook(viewport, settings)

    # MP4 render via ffmpeg
    try:
        ffmpeg = get_ffmpeg_bin()

        mp4_dir = os.path.normpath(os.path.join(flipbook_dir, "mp4"))
        os.makedirs(mp4_dir, exist_ok=True)

        exr_seq = os.path.normpath(os.path.join(version_folder, f"{hip_name}_{version_str}.%04d.exr"))
        mp4_path = os.path.normpath(os.path.join(mp4_dir, f"{hip_name}.{version_str}.mp4"))

        cmd = [
            ffmpeg,
            "-y",
            "-start_number", str(start_frame),
            "-framerate", "24",
            "-i", exr_seq,
            "-c:v", "libx264",
            "-preset", "veryslow",
            "-crf", "0",  # Lossless CRF
            "-pix_fmt", "yuv444p",  # Full chroma (optional, if source supports it)
            mp4_path
        ]

        result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if result.returncode != 0:
            raise hou.Error("FFmpeg failed:\n" + result.stderr.decode())

        if open_after:
            if sys.platform == "win32":
                os.startfile(mp4_path)
            elif sys.platform == "darwin":
                subprocess.call(["open", mp4_path])
            else:
                subprocess.call(["xdg-open", mp4_path])

    except Exception as e:
        hou.ui.displayMessage(f"Flipbook succeeded, but MP4 creation failed:\n{e}")


main()
]]></script>
  </tool>

  <tool name="OpenGlFlipbook0" label="OpenGlFlipbook" icon="$PLAB/icons/OpenGLFlipbook.png">
    <script scriptType="python"><![CDATA[import hou
import os
import re
import subprocess
import sys
from PySide2 import QtWidgets, QtCore

def get_ffmpeg_bin():
    PLAB = os.getenv("PLAB")
    if not PLAB:
        raise hou.Error("Environment variable PLAB is not set.")
    ffmpeg = os.path.join(PLAB, "ffmpeg", "bin", "ffmpeg.exe")
    if not os.path.exists(ffmpeg):
        raise hou.Error(f"ffmpeg.exe not found at:\n{ffmpeg}")
    return ffmpeg

def find_next_version(base_folder):
    if not os.path.exists(base_folder):
        return "V001"
    versions = [entry for entry in os.listdir(base_folder)
                if os.path.isdir(os.path.join(base_folder, entry)) and re.match(r"V\d{3}", entry)]
    if not versions:
        return "V001"
    versions.sort()
    last_version = versions[-1]
    next_version_number = int(last_version[1:]) + 1
    return f"V{next_version_number:03}"

class FlipbookDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, start="1001", end="1100", version="V001"):
        super().__init__(parent)
        self.setWindowTitle("Flipbook Parameters")
        self.setFixedWidth(300)

        form_layout = QtWidgets.QFormLayout(self)

        self.start_edit = QtWidgets.QLineEdit(start)
        self.end_edit = QtWidgets.QLineEdit(end)
        self.version_edit = QtWidgets.QLineEdit(version)
        self.open_checkbox = QtWidgets.QCheckBox("Open MP4 after render")
        self.open_checkbox.setChecked(False)  # Default to OFF

        form_layout.addRow("Start Frame:", self.start_edit)
        form_layout.addRow("End Frame:", self.end_edit)
        form_layout.addRow("Version:", self.version_edit)
        form_layout.addRow("", self.open_checkbox)

        button_layout = QtWidgets.QHBoxLayout()
        self.flipbook_button = QtWidgets.QPushButton("Flipbook")
        self.cancel_button = QtWidgets.QPushButton("Cancel")
        button_layout.addWidget(self.flipbook_button)
        button_layout.addWidget(self.cancel_button)

        form_layout.addRow(button_layout)

        self.flipbook_button.clicked.connect(self.validate_and_accept)
        self.cancel_button.clicked.connect(self.reject)

    def validate_and_accept(self):
        if not self.start_edit.text().isdigit() or not self.end_edit.text().isdigit():
            QtWidgets.QMessageBox.warning(self, "Invalid Input", "Start and End frames must be integers.")
            return
        if not self.version_edit.text().strip():
            QtWidgets.QMessageBox.warning(self, "Invalid Input", "Version cannot be empty.")
            return
        self.accept()

    def get_values(self):
        return (
            self.start_edit.text(),
            self.end_edit.text(),
            self.version_edit.text().strip(),
            self.open_checkbox.isChecked()
        )

def open_sequence_in_mplay(first_frame_path, total_frames):
    match = re.match(r"(.*?)(\d+)\.exr$", os.path.basename(first_frame_path))
    if not match:
        hou.ui.displayMessage("Invalid EXR filename format.")
        return

    prefix, frame_str = match.groups()
    start_frame = int(frame_str)
    end_frame = start_frame + total_frames - 1
    padding = len(frame_str)

    sequence_pattern = f"{prefix}$F{padding}.exr"
    directory = os.path.dirname(first_frame_path)
    full_pattern = os.path.join(directory, sequence_pattern)

    mplay_path = os.path.join(hou.getenv("HFS"), "bin", "mplay")

    try:
        # Pass start, end, and step ('1') as separate arguments after '-f'
        subprocess.Popen([mplay_path, "-f", str(start_frame), str(end_frame), "1", full_pattern])
    except Exception as e:
        hou.ui.displayMessage(f"Could not launch MPlay:\n{str(e)}")


def main():
    ffmpeg_bin = get_ffmpeg_bin()

    hipfile = hou.hipFile.path()
    hip = os.path.dirname(hipfile)
    hip_name = os.path.splitext(os.path.basename(hipfile))[0]

    base = os.path.join(hip, "Flipbooks")
    version_guess = find_next_version(base)

    start, end = hou.playbar.frameRange()
    default_start = str(int(start))
    default_end = str(int(end))

    app = QtWidgets.QApplication.instance()
    if not app:
        app = QtWidgets.QApplication([])

    dialog = FlipbookDialog(start=default_start, end=default_end, version=version_guess)
    if dialog.exec_() != QtWidgets.QDialog.Accepted:
        return  # silently exit if user cancels

    start_f_str, end_f_str, user_version, open_after = dialog.get_values()
    start_f = int(start_f_str)
    end_f = int(end_f_str)

    exr_folder = os.path.join(base, user_version)
    os.makedirs(exr_folder, exist_ok=True)

    viewer = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer)
    if not viewer:
        raise hou.Error("No Scene Viewer found.")
    viewport = viewer.curViewport()
    camera = viewport.camera()
    if not camera:
        raise hou.Error("Lock a camera to the viewport before running the script.")

    resx = int(camera.parm("resx").eval())
    resy = int(camera.parm("resy").eval())

    # Create temporary OpenGL ROP
    rop = hou.node("/out").createNode("opengl", node_name="temp_flipbook")
    exr_pattern = os.path.join(exr_folder, f"{hip_name}_{user_version}.$F4.exr")
    rop.setParms({
        "camera": camera.path(),
        "trange": 1,
        "f1": start_f,
        "f2": end_f,
        "f3": 1,
        "res1": resx,
        "res2": resy,
        "tres": True,
        "picture": exr_pattern,
        "alights": "",
        "aamode": 6,  # High quality AA
        "usehdr": 2   # HDR setting
    })

    if camera.parm("vm_background"):
        bg_image = camera.parm("vm_background").unexpandedString()
        if bg_image:
            rop.parm("bgimage").set(bg_image)
    if rop.parm("soho_initsim"):
        rop.parm("soho_initsim").set(True)

    rop.parm("execute").pressButton()
    rop.destroy()

    mp4_dir = os.path.join(base, "mp4")
    os.makedirs(mp4_dir, exist_ok=True)
    mp4_path = os.path.join(mp4_dir, f"{hip_name}.{user_version}.mp4")
    exr_input_pattern = os.path.join(exr_folder, f"{hip_name}_{user_version}.%04d.exr")

    cmd = [
        ffmpeg_bin,
        "-y",
        "-start_number", str(start_f),
        "-framerate", "24",
        "-i", exr_input_pattern,
        "-c:v", "libx264",
        "-preset", "veryslow",
        "-crf", "0",
        "-pix_fmt", "yuv444p",
        mp4_path
    ]

    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if result.returncode != 0:
        raise hou.Error("FFmpeg conversion failed:\n" + result.stderr.decode())

    if open_after:
        try:
            if os.name == "nt":
                os.startfile(mp4_path.replace("/", "\\"))
            elif sys.platform == "darwin":
                subprocess.call(["open", mp4_path])
            else:
                subprocess.call(["xdg-open", mp4_path])
        except Exception as e:
            hou.ui.displayMessage(f"Rendered but could not open MP4:\n{str(e)}")

    # Open in MPlay by default
    first_frame_path = os.path.join(exr_folder, f"{hip_name}_{user_version}.{start_f:04d}.exr")
    open_sequence_in_mplay(first_frame_path, end_f - start_f + 1)

main()
]]></script>
  </tool>

  <tool name="CacheManager0" label="CacheManager" icon="$PLAB/icons/cache.png">
    <script scriptType="python"><![CDATA[
import os
import sys
import shutil
import subprocess
from functools import partial
import hou

from PySide2 import QtWidgets, QtCore, QtGui


class CacheBrowser(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super(CacheBrowser, self).__init__(parent)
        self.setWindowTitle("Cache Browser")

        # â Normal Windows-style window with Minimize / Maximize / Close
        self.setWindowFlags(QtCore.Qt.Window |
                            QtCore.Qt.WindowMinimizeButtonHint |
                            QtCore.Qt.WindowMaximizeButtonHint |
                            QtCore.Qt.WindowCloseButtonHint)

        self.resize(900, 550)

        # --- Main Layout ---
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.setContentsMargins(2, 2, 2, 2)
        main_layout.setSpacing(2)

        # --- Path Selector ---
        path_layout = QtWidgets.QHBoxLayout()
        self.path_edit = QtWidgets.QLineEdit()
        self.path_edit.setReadOnly(True)

        set_path_btn = QtWidgets.QPushButton("Set Folder")
        set_path_btn.setFixedWidth(100)
        set_path_btn.clicked.connect(self.set_cache_dir)

        path_layout.addWidget(QtWidgets.QLabel("Cache Path:"))
        path_layout.addWidget(self.path_edit, 1)
        path_layout.addWidget(set_path_btn)
        main_layout.addLayout(path_layout)

        # --- Top Bar (Search + Refresh) ---
        top_layout = QtWidgets.QHBoxLayout()
        self.search_bar = QtWidgets.QLineEdit()
        self.search_bar.setPlaceholderText("ð Search caches...")
        self.search_bar.textChanged.connect(self.filter_cache_tree)
        top_layout.addWidget(self.search_bar)

        refresh_btn = QtWidgets.QPushButton("â³ Refresh")
        refresh_btn.setFixedWidth(100)
        refresh_btn.clicked.connect(self.populate_cache_tree)
        top_layout.addWidget(refresh_btn)

        main_layout.addLayout(top_layout)

        # --- Cache Tree ---
        self.cache_tree = QtWidgets.QTreeWidget()
        self.cache_tree.setHeaderLabels(["Cache Name", "Date Modified", "Size"])
        self.cache_tree.setColumnWidth(0, 350)
        self.cache_tree.setColumnWidth(1, 180)
        self.cache_tree.setColumnWidth(2, 120)
        self.cache_tree.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.cache_tree.customContextMenuRequested.connect(self.show_cache_context_menu)
        self.cache_tree.itemDoubleClicked.connect(self.on_item_double_clicked)
        self.cache_tree.setSortingEnabled(True)
        main_layout.addWidget(self.cache_tree, 1)

        # --- Bottom Status ---
        bottom_layout = QtWidgets.QVBoxLayout()
        self.status_label = QtWidgets.QLabel("Ready")
        self.disk_summary_label = QtWidgets.QLabel("")
        bottom_layout.addWidget(self.status_label)
        bottom_layout.addWidget(self.disk_summary_label)
        main_layout.addLayout(bottom_layout)

        # --- Load Settings ---
        self.settings = QtCore.QSettings("PLAB", "CacheBrowser")
        saved_path = self.settings.value("cache_dir", "")

        if saved_path and os.path.exists(saved_path):
            self.cache_dir = os.path.normpath(os.path.abspath(saved_path))
        else:
            hip_path = hou.getenv("HIP")
            default1 = os.path.join(hip_path, "Cache")
            default2 = os.path.join(hip_path, "cache")
            if os.path.exists(default1):
                self.cache_dir = os.path.normpath(os.path.abspath(default1))
            elif os.path.exists(default2):
                self.cache_dir = os.path.normpath(os.path.abspath(default2))
            else:
                self.cache_dir = os.path.normpath(os.path.abspath(default1))

        self.path_edit.setText(self.cache_dir)

        # --- Populate Initial Data ---
        self.populate_cache_tree()
        self.center_on_parent()
        self.apply_dark_theme()

    # -------------------------------
    # Cache Population
    # -------------------------------
    def populate_cache_tree(self):
        cache_dir = self.cache_dir
        self.cache_tree.clear()

        if not os.path.exists(cache_dir):
            self.status_label.setText("No Cache directory found.")
            self.disk_summary_label.setText("")
            return

        total_size_bytes = 0

        for cache_name in os.listdir(cache_dir):
            cache_path = os.path.join(cache_dir, cache_name)
            if os.path.isdir(cache_path):
                last_modified = self.get_last_modified_time(cache_path)
                folder_size_bytes = self.get_folder_size_bytes(cache_path)
                total_size_bytes += folder_size_bytes

                parent_item = QtWidgets.QTreeWidgetItem([
                    cache_name,
                    last_modified,
                    self.format_size(folder_size_bytes)
                ])
                self.cache_tree.addTopLevelItem(parent_item)

                # Add version subfolders
                for version in sorted(os.listdir(cache_path)):
                    version_path = os.path.join(cache_path, version)
                    if os.path.isdir(version_path) and version.startswith("v"):
                        version_size_bytes = self.get_folder_size_bytes(version_path)
                        version_item = QtWidgets.QTreeWidgetItem([
                            version,
                            self.get_last_modified_time(version_path),
                            self.format_size(version_size_bytes)
                        ])
                        parent_item.addChild(version_item)

                # Expand only if more than 1 version exists
                parent_item.setExpanded(parent_item.childCount() > 1)

        # Update summary
        self.status_label.setText("Cache list updated.")
        self.update_disk_summary(cache_dir, total_size_bytes)

    def get_last_modified_time(self, path):
        try:
            mtime = os.path.getmtime(path)
            return QtCore.QDateTime.fromSecsSinceEpoch(int(mtime)).toString("yyyy-MM-dd hh:mm")
        except Exception:
            return "Unknown"

    def get_folder_size_bytes(self, path):
        total = 0
        for root, _, files in os.walk(path):
            for f in files:
                try:
                    total += os.path.getsize(os.path.join(root, f))
                except Exception:
                    pass
        return total

    def format_size(self, size):
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024:
                return f"{size:.1f} {unit}"
            size /= 1024
        return f"{size:.1f} PB"

    def update_disk_summary(self, cache_dir, total_cache_size):
        try:
            usage = shutil.disk_usage(cache_dir)
            free_space = usage.free
            self.disk_summary_label.setText(
                f"ð¦ Total Cache Size: {self.format_size(total_cache_size)} | ð¾ Free Disk Space: {self.format_size(free_space)}"
            )
        except Exception as e:
            self.disk_summary_label.setText(f"Disk usage info unavailable: {e}")

    # -------------------------------
    # Path Setter
    # -------------------------------
    def set_cache_dir(self):
        dir_ = QtWidgets.QFileDialog.getExistingDirectory(self, "Select Cache Directory", self.cache_dir)
        if dir_:
            self.cache_dir = os.path.normpath(os.path.abspath(dir_))
            self.path_edit.setText(self.cache_dir)
            # Save user preference
            self.settings.setValue("cache_dir", self.cache_dir)
            self.populate_cache_tree()

    # -------------------------------
    # Search Filter
    # -------------------------------
    def filter_cache_tree(self, text):
        text = text.lower()
        for i in range(self.cache_tree.topLevelItemCount()):
            parent = self.cache_tree.topLevelItem(i)
            parent_visible = text in parent.text(0).lower()
            child_visible = False
            for j in range(parent.childCount()):
                child = parent.child(j)
                match = text in child.text(0).lower()
                child.setHidden(not match)
                if match:
                    child_visible = True
            parent.setHidden(not (parent_visible or child_visible))

    # -------------------------------
    # Context Menu
    # -------------------------------
    def show_cache_context_menu(self, pos):
        item = self.cache_tree.itemAt(pos)
        if not item:
            return
    
        path = self.get_item_path(item)
    
        menu = QtWidgets.QMenu(self)
    
        # Enable true transparency
        menu.setWindowFlags(menu.windowFlags() | QtCore.Qt.FramelessWindowHint | QtCore.Qt.NoDropShadowWindowHint)
        menu.setAttribute(QtCore.Qt.WA_TranslucentBackground, True)
    
        # Apply flat, rounded, transparent style
        menu.setStyleSheet("""
            QMenu {
                background-color: rgba(40, 40, 40, 180);
                border-radius: 6px;
                padding: 2px;
                color: #ffffff;
            }
            QMenu::item {
                padding: 2px 20px;
                border-radius: 6px;
                background-color: transparent;
            }
            QMenu::item:selected {
                background-color: rgba(255, 255, 255, 50);
                color: #ffffff;
            }
        """)
    
        open_action = menu.addAction("ð Open Folder")
        copy_action = menu.addAction("ð Copy Path")
        delete_action = menu.addAction("ðï¸ Delete Cache")
        override_action = menu.addAction("â¬ Override with Blank")
    
        action = menu.exec_(self.cache_tree.viewport().mapToGlobal(pos))
        if action == open_action:
            self.open_folder(path)
        elif action == copy_action:
            QtWidgets.QApplication.clipboard().setText(path)
            self.status_label.setText("Path copied to clipboard")
        elif action == delete_action:
            self.delete_cache_folder(path)
        elif action == override_action:
            self.override_with_blank(path)

    def get_item_path(self, item):
        parts = []
        while item:
            parts.insert(0, item.text(0).split()[0])
            item = item.parent()
        return os.path.normpath(os.path.abspath(os.path.join(self.cache_dir, *parts)))

    # -------------------------------
    # File Ops
    # -------------------------------
    def open_folder(self, path):
        try:
            if os.path.exists(path):
                if sys.platform == "win32":
                    os.startfile(path)
                elif sys.platform == "darwin":
                    subprocess.Popen(["open", path])
                else:
                    subprocess.Popen(["xdg-open", path])
        except Exception as e:
            print(f"Open folder failed: {e}")

    def delete_cache_folder(self, path):
        reply = QtWidgets.QMessageBox.question(
            self,
            "Delete Cache",
            f"Are you sure you want to delete:\n{path} ?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        )
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                shutil.rmtree(path)
                self.populate_cache_tree()
            except Exception as e:
                print(f"Failed to delete cache folder {path}: {e}")

    def override_with_blank(self, path):
        try:
            for root, _, files in os.walk(path):
                for f in files:
                    open(os.path.join(root, f), 'wb').close()
            self.status_label.setText("Cache overridden with blank files.")
        except Exception as e:
            print(f"Failed to override cache: {e}")

    # -------------------------------
    # Double-click opens folder
    # -------------------------------
    def on_item_double_clicked(self, item, column):
        path = self.get_item_path(item)
        self.open_folder(path)

    # -------------------------------
    # Helpers
    # -------------------------------
    def center_on_parent(self):
        if self.parent():
            parent_geom = self.parent().frameGeometry()
            self.move(parent_geom.center() - self.rect().center())
        else:
            screen = QtWidgets.QDesktopWidget().screenGeometry()
            self.move(
                (screen.width() - self.width()) // 2,
                (screen.height() - self.height()) // 2
            )

    def apply_dark_theme(self):
        modern_stylesheet = """
            QWidget {
                background-color: #1e1e1e;
                color: #f0f0f0;
                border-radius: 4px;
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                font-size: 12px;
            }
            QLabel {
                background: transparent;
                border: none;
                color: #aaaaaa;
                font-size: 12px;
                padding: 0px;
            }
            QLineEdit {
                background-color: #2c2c2c;
                border: 1px solid #444;
                border-radius: 4px;
                padding: 0px 0px;
                color: #fff;
            }
            QLineEdit:focus {
                border: 1px solid #888;
                background-color: #333;
            }
            QTreeWidget {
                background-color: #1e1e1e;
                border: none;
                outline: none;
            }
            QTreeWidget::item {
                background-color: transparent;
                margin: 0px 0px;
                padding: 2px;
                border-radius: 0px;
                color: #ddd;
            }
            QTreeWidget::item:selected {
                background-color: #3a6ea5;
                color: #ffffff;
            }
            QTreeWidget::item:hover {
                background-color: #2d2d2d;
                color: #fff;
            }
            QHeaderView::section {
                background-color: #1e1e1e;
                color: #bbbbbb;
                border: none;
                border-bottom: 2px solid #333;
                padding: 2px;
                font-weight: 500;
            }
            QPushButton {
                background-color: #bfbfbf;
                color: #1e1e1e;    
                padding: 2px 2px;
                border-radius: 4px;
                font-weight: 500;
                border: none;
            }
            QPushButton:hover {
                background-color: #505050;
            }
            QPushButton:pressed {
                background-color: #606060;
            }
        """
        self.setStyleSheet(modern_stylesheet)


# -------------------------------
# Launch Helper
# -------------------------------
_cache_browser_instance = None

def show_cache_browser():
    global _cache_browser_instance
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])

    if _cache_browser_instance is None:
        _cache_browser_instance = CacheBrowser()

        def reset_instance():
            global _cache_browser_instance
            _cache_browser_instance = None

        _cache_browser_instance.destroyed.connect(reset_instance)

    _cache_browser_instance.show()
    _cache_browser_instance.raise_()
    _cache_browser_instance.activateWindow()

    if not QtWidgets.QApplication.instance():
        app.exec_()


# -------------------------------
# Run
# -------------------------------
show_cache_browser()
]]></script>
  </tool>

  <tool name="FlipbookBrowser0" label="FlipbookBrowser" icon="$PLAB/icons/flipbookbrowser.png">
    <script scriptType="python"><![CDATA[import os
import glob
import subprocess
import numpy as np
import OpenImageIO as oiio
from PySide2 import QtWidgets, QtGui, QtCore
import hou
import re

# Close any previous instance
for w in QtWidgets.QApplication.allWidgets():
    if w.objectName() == "FlipbookImageSequenceBrowser":
        w.close()


def load_exr_thumbnail(path, size=(160, 90)):
    img = oiio.ImageInput.open(path)
    if not img:
        return None
    spec = img.spec()
    pixels = img.read_image(format=oiio.FLOAT)
    img.close()
    if pixels is None:
        return None

    w, h = spec.width, spec.height
    c = spec.nchannels if spec.nchannels is not None else 1

    pixels = np.clip(pixels, 0.0, 1.0)
    arr = (pixels * 255).astype(np.uint8)

    # Handle different channel counts
    if c == 1:
        arr = arr.reshape(h, w)
        fmt = QtGui.QImage.Format_Grayscale8
    elif c == 2:
        arr = arr.reshape(h, w, 2)
        arr = arr[:, :, 0]  # take first channel
        fmt = QtGui.QImage.Format_Grayscale8
    elif c == 3:
        arr = arr.reshape(h, w, 3)
        fmt = QtGui.QImage.Format_RGB888
    elif c >= 4:
        arr = arr.reshape(h, w, c)[:, :, :4]
        fmt = QtGui.QImage.Format_RGBA8888
    else:
        return None

    arr = np.ascontiguousarray(arr)
    qimg = QtGui.QImage(arr.data, w, h, w * arr.shape[-1], fmt).copy()
    return QtGui.QPixmap.fromImage(qimg.scaled(*size, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))


from PySide2.QtGui import QPainter, QColor, QFont


def add_overlay_text(pixmap, resolution, frame_range):
    painter = QPainter(pixmap)
    painter.setRenderHint(QPainter.TextAntialiasing)

    margin = 6
    rect = pixmap.rect().adjusted(margin, margin, -margin, -margin)
    text = f"{resolution[0]}x{resolution[1]}\n{frame_range[0]}-{frame_range[1]}"

    painter.setPen(QColor("white"))
    painter.setFont(QFont("Segoe UI", 6, QFont.Normal))
    painter.drawText(rect, QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop, text)
    painter.end()
    return pixmap


class EXRFlipbookBrowser(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setObjectName("FlipbookImageSequenceBrowser")
        self.setWindowTitle("EXR Flipbook Browser")
        self.setMinimumSize(900, 550)

        self.setStyleSheet("""
            QWidget {
                background-color: #1e1e1e;
                color: #FFFFFF;
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                font-size: 12px;
            }
            QListWidget {
                background-color: #2c2c2c;
                border: none;
                border-radius: 6px;
                outline: none;
            }
            QListWidget::item {
                background-color: #3a3a3a;
                margin: 6px 10px;
                padding: 6px;
                border-radius: 6px;
                color: #EEE;
            }
            QListWidget::item:selected {
                background-color: #505050;
                color: #FFFFFF;
            }
            QListWidget::item:hover {
                background-color: #606060;
                color: #FFFFFF;
            }
            QPushButton {
                background-color: #bfbfbf;
                color: #1e1e1e;
                padding: 4px 4px;
                border-radius: 6px;
                font-weight: 400;
                min-width: 4px;
            }
            QPushButton:hover {
                background-color: #FFFFFF;
                color: #000000;
            }
            QPushButton:pressed {
                background-color: #d9d9d9;
                color: #000000;
            }
            QMenu {
                background-color: #2c2c2c;
                color: #FFFFFF;
                border-radius: 6px;
                padding: 4px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 6px;
            }
            QMenu::item:selected {
                background-color: #505050;
                color: #FFF;
            }
        """)

        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.setViewMode(QtWidgets.QListView.IconMode)
        self.list_widget.setIconSize(QtCore.QSize(160, 90))
        self.list_widget.setGridSize(QtCore.QSize(180, 130))
        self.list_widget.setSpacing(12)
        self.list_widget.setResizeMode(QtWidgets.QListView.Adjust)
        self.list_widget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.list_widget.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.list_widget.customContextMenuRequested.connect(self.show_context_menu)
        self.list_widget.itemDoubleClicked.connect(self.open_in_mplay)

        font = QtGui.QFont("Segoe UI", 11)
        self.list_widget.setFont(font)

        self.refresh_btn = QtWidgets.QPushButton("Refresh")
        self.refresh_btn.setFont(font)
        self.refresh_btn.clicked.connect(self.start_thumbnail_loading)

        self.mp4_btn = QtWidgets.QPushButton("Open MP4 Folder")
        self.mp4_btn.setFont(font)
        self.mp4_btn.clicked.connect(self.open_mp4_folder)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_layout.addWidget(self.refresh_btn)
        btn_layout.addWidget(self.mp4_btn)
        btn_layout.addStretch()

        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.addWidget(self.list_widget)
        main_layout.addLayout(btn_layout)

        self.folders = []
        self.thumbnail_index = 0
        self.item_lookup = {}

        self.timer = QtCore.QTimer()
        self.timer.setInterval(50)
        self.timer.timeout.connect(self.load_next_thumbnail)

        QtCore.QTimer.singleShot(100, self.start_thumbnail_loading)

    def hip_root(self):
        return os.path.join(os.path.normpath(os.path.expandvars("$HIP")), "Flipbooks")

    def start_thumbnail_loading(self):
        self.list_widget.clear()
        self.item_lookup.clear()
        self.timer.stop()

        root = self.hip_root()
        if not os.path.isdir(root):
            return

        self.folders = []
        seen_paths = set()

        for name in sorted(os.listdir(root)):
            folder_path = os.path.abspath(os.path.join(root, name))
            if folder_path in seen_paths or not os.path.isdir(folder_path):
                continue

            exrs = sorted(glob.glob(os.path.join(folder_path, "*.exr")))
            if not exrs:
                continue

            seen_paths.add(folder_path)
            self.folders.append((name, folder_path, exrs))

            placeholder = QtGui.QPixmap(160, 90)
            placeholder.fill(QtGui.QColor("gray"))
            item = QtWidgets.QListWidgetItem(QtGui.QIcon(placeholder), name)
            item.setData(QtCore.Qt.UserRole, exrs)
            self.list_widget.addItem(item)
            self.item_lookup[folder_path] = item

        self.thumbnail_index = 0
        self.timer.start()

    def load_next_thumbnail(self):
        if self.thumbnail_index >= len(self.folders):
            self.timer.stop()
            return

        name, folder_path, exrs = self.folders[self.thumbnail_index]
        thumb = load_exr_thumbnail(exrs[0])
        if thumb:
            img = oiio.ImageInput.open(exrs[0])
            spec = img.spec() if img else None
            if img:
                img.close()
            resolution = (spec.width, spec.height) if spec else (0, 0)

            frames = []
            for f in exrs:
                base = os.path.splitext(os.path.basename(f))[0]
                m = re.search(r'(\d+)$', base)
                if m:
                    frames.append(int(m.group(1)))
            if frames:
                frame_range = (min(frames), max(frames))
            else:
                frame_range = (0, 0)

            overlay_pixmap = add_overlay_text(thumb.copy(), resolution, frame_range)
            self.item_lookup[folder_path].setIcon(QtGui.QIcon(overlay_pixmap))

        self.thumbnail_index += 1

    def show_context_menu(self, pos):
        items = self.list_widget.selectedItems()
        if not items:
            return
    
        folder_path = os.path.dirname(items[0].data(QtCore.Qt.UserRole)[0])
    
        menu = QtWidgets.QMenu()
        menu.addAction("Open in MPlay", lambda: self.open_in_mplay(items[0]))
        menu.addAction("Open Folder", lambda: self.open_folder(folder_path))
        menu.addAction("Copy Path", lambda: QtWidgets.QApplication.clipboard().setText(folder_path))
    
        # Remove window frame, shadow, and make transparent
        menu.setWindowFlags(menu.windowFlags() | QtCore.Qt.FramelessWindowHint | QtCore.Qt.NoDropShadowWindowHint)
        menu.setAttribute(QtCore.Qt.WA_TranslucentBackground)
        
        # Apply flat rounded style
        menu.setStyleSheet("""
            QMenu {
                background-color: rgba(40, 40, 40, 220);  /* semi-transparent dark */
                border-radius: 6px;
                padding: 2px;
                color: #ffffff;
            }
            QMenu::item {
                padding: 2px 20px;
                border-radius: 6px;
                background-color: transparent;
            }
            QMenu::item:selected {
                background-color: rgba(255, 255, 255, 50);
                color: #ffffff;
            }
        """)
    
        menu.exec_(self.list_widget.viewport().mapToGlobal(pos))


    def open_folder(self, path):
        if os.name == "nt":
            os.startfile(path)
        else:
            subprocess.Popen(["open", path])

    def open_mp4_folder(self):
        path = os.path.join(self.hip_root(), "mp4")
        os.makedirs(path, exist_ok=True)
        self.open_folder(path)

    def open_in_mplay(self, item):
        exr_sequence = item.data(QtCore.Qt.UserRole)
        if not exr_sequence:
            return

        folder = os.path.dirname(exr_sequence[0])
        files = sorted(os.path.basename(f) for f in exr_sequence)

        pattern = re.compile(r"(.*?)(\d+)(\.[^.]+)$")
        matches = [pattern.match(f) for f in files if pattern.match(f)]

        if matches:
            base = matches[0].group(1)
            start = int(matches[0].group(2))
            end = int(matches[-1].group(2))
            ext = matches[0].group(3)
            padding = len(matches[0].group(2))
            sequence = os.path.join(folder, f"{base}$F{padding}{ext}")

            subprocess.Popen(["mplay", "-f", str(start), str(end), "1", sequence])
            return

        subprocess.Popen(["mplay"] + exr_sequence)


def launch_browser():
    global flipbook_browser
    flipbook_browser = EXRFlipbookBrowser()
    flipbook_browser.show()


try:
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])
    launch_browser()
except Exception as e:
    print(f"Error: {e}")
]]></script>
  </tool>

  <tool name="DeadlineManager0" label="DeadlineManager" icon="$PLAB/icons/deadline.png">
    <script scriptType="python"><![CDATA[import os
import re
import platform
import getpass
import subprocess
from PySide2 import QtWidgets, QtCore
from PySide2.QtCore import QDate, QDateTime
from PySide2.QtWidgets import QLabel


# ---------------------------
# Worker threads
# ---------------------------
class DeadlineJobLoader(QtCore.QThread):
    jobs_loaded = QtCore.Signal(list)  # list of job dicts
    error = QtCore.Signal(str)

    def __init__(self, deadline_cmd, user=None, parent=None):
        super().__init__(parent)
        self.deadline_cmd = deadline_cmd
        self.user = user

    def run(self):
        jobs = []
        try:
            args = [self.deadline_cmd, "GetJobs"]
            if self.user:
                args += ["-UserName", self.user]
            result = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            out = result.stdout.strip() or result.stderr.strip()
            current_job = {}
            for line in out.splitlines():
                if "=" in line:
                    k, v = line.split("=", 1)
                    current_job[k.strip()] = v.strip()
                elif not line.strip():  # blank line => job boundary
                    if current_job:
                        jobs.append(current_job.copy())
                        current_job.clear()
            if current_job:
                jobs.append(current_job.copy())
        except Exception as e:
            self.error.emit(str(e))
        finally:
            self.jobs_loaded.emit(jobs)


class JobInfoLoader(QtCore.QThread):
    info_loaded = QtCore.Signal(dict)
    error = QtCore.Signal(str)

    def __init__(self, deadline_cmd, job_id, parent=None):
        super().__init__(parent)
        self.deadline_cmd = deadline_cmd
        self.job_id = job_id

    def run(self):
        parsed = {}
        try:
            result = subprocess.run([self.deadline_cmd, "GetJob", self.job_id], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            out = result.stdout.strip() or result.stderr.strip()
            for line in out.splitlines():
                if "=" in line:
                    k, v = line.split("=", 1)
                    parsed[k.strip()] = v.strip()
        except Exception as e:
            self.error.emit(str(e))
        finally:
            self.info_loaded.emit(parsed)


class CommandRunner(QtCore.QThread):
    finished_running = QtCore.Signal(str, bool, str)  # command, success, message

    def __init__(self, deadline_cmd, command, job_id, parent=None):
        super().__init__(parent)
        self.deadline_cmd = deadline_cmd
        self.command = command
        self.job_id = job_id

    def run(self):
        try:
            result = subprocess.run([self.deadline_cmd, self.command, self.job_id], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            success = result.returncode == 0
            msg = (result.stdout.strip() or result.stderr.strip())
            self.finished_running.emit(self.command, success, msg)
        except Exception as e:
            self.finished_running.emit(self.command, False, str(e))

# ---------------------------
# Main GUI
# ---------------------------
class DeadlineGUI(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Deadline Jobs Viewer")
        self.resize(900, 550)
        self.apply_dark_theme()
        self.jobs = []
        self.threads = []  # keep references to threads to avoid GC
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(self.create_deadline_page())

    def closeEvent(self, event):
        """Reset global instance on close so it can be reopened."""
        app = QtWidgets.QApplication.instance()
        if hasattr(app, "_deadline_viewer_instance"):
            app._deadline_viewer_instance = None
        super().closeEvent(event)
        
    def create_deadline_page(self):
        left = QtWidgets.QWidget()
        left_layout = QtWidgets.QVBoxLayout(left)

        # Filters
        filter_layout = QtWidgets.QHBoxLayout()
        self.search_bar = QtWidgets.QLineEdit()
        self.search_bar.setPlaceholderText("ð Search jobs (name/user/id)...")
        self.search_bar.textChanged.connect(self.apply_deadline_filter)
        filter_layout.addWidget(self.search_bar)

        self.user_filter = QtWidgets.QComboBox()
        self.user_filter.setEditable(True)
        self.user_filter.setMinimumWidth(140)
        self.user_filter.addItem(getpass.getuser())
        self.user_filter.setCurrentText(getpass.getuser())
        self.user_filter.currentIndexChanged.connect(self.apply_deadline_filter)
        filter_layout.addWidget(QLabel("User:"))
        filter_layout.addWidget(self.user_filter)

        self.date_start = QtWidgets.QDateEdit(calendarPopup=True)
        self.date_end = QtWidgets.QDateEdit(calendarPopup=True)
        self.date_start.setDate(QDate.currentDate().addDays(-7))
        self.date_end.setDate(QDate.currentDate())
        self.date_start.dateChanged.connect(self.apply_deadline_filter)
        self.date_end.dateChanged.connect(self.apply_deadline_filter)
        filter_layout.addWidget(QLabel("From:"))
        filter_layout.addWidget(self.date_start)
        filter_layout.addWidget(QLabel("To:"))
        filter_layout.addWidget(self.date_end)

        self.auto_refresh_chk = QtWidgets.QCheckBox("Auto-refresh")
        self.auto_refresh_chk.setToolTip("Automatically refresh deadline jobs every interval")
        self.auto_refresh_chk.stateChanged.connect(self._toggle_deadline_autorefresh)
        filter_layout.addWidget(self.auto_refresh_chk)

        self.auto_interval = QtWidgets.QSpinBox()
        self.auto_interval.setMinimum(5)
        self.auto_interval.setMaximum(3600)
        self.auto_interval.setValue(20)
        self.auto_interval.setSuffix(" s")
        self.auto_interval.setToolTip("Auto-refresh interval (seconds)")
        filter_layout.addWidget(self.auto_interval)

        self.refresh_btn = QtWidgets.QPushButton("ð Refresh")
        self.refresh_btn.clicked.connect(self.load_deadline_jobs)
        filter_layout.addWidget(self.refresh_btn)

        left_layout.addLayout(filter_layout)

        # Job table
        self.deadline_table = QtWidgets.QTableWidget()
        self.deadline_table.setColumnCount(14)
        self.deadline_table.setHorizontalHeaderLabels([
            "Job Name", "User", "Progress", "Status", "Frames", "Pool",
            "Priority", "Submitted", "Started", "Completed",
            "Output Directory", "Output File", "Submitted From", "Job ID"
        ])
        self.deadline_table.setSortingEnabled(True)
        self.deadline_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.deadline_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.deadline_table.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.deadline_table.customContextMenuRequested.connect(self.show_deadline_context_menu)
        self.deadline_table.itemSelectionChanged.connect(self._deadline_row_selected)
        self.deadline_table.itemDoubleClicked.connect(self._deadline_row_selected)
        left_layout.addWidget(self.deadline_table)

        # Action buttons
        actions_row = QtWidgets.QHBoxLayout()
        self.suspend_btn = QtWidgets.QPushButton("ð Suspend")
        self.resume_btn = QtWidgets.QPushButton("â¶ï¸ Resume")
        self.delete_btn = QtWidgets.QPushButton("â Delete")
        self.suspend_btn.clicked.connect(self.suspend_selected_jobs)
        self.resume_btn.clicked.connect(self.resume_selected_jobs)
        self.delete_btn.clicked.connect(self.delete_selected_jobs)
        actions_row.addWidget(self.suspend_btn)
        actions_row.addWidget(self.resume_btn)
        actions_row.addWidget(self.delete_btn)
        actions_row.addStretch()
        left_layout.addLayout(actions_row)

        main = QtWidgets.QHBoxLayout()
        main.addWidget(left)


        page = QtWidgets.QWidget()
        page.setLayout(main)

        self._deadline_timer = QtCore.QTimer(self)
        self._deadline_timer.timeout.connect(self.load_deadline_jobs)

        return page

    def apply_dark_theme(self):
        modern_stylesheet = """
        QWidget {
            background-color: #2b2b2b;
            color: #dddddd;
            font-family: "Segoe UI", "Arial", sans-serif;
            font-size: 8pt;
        }
        QLineEdit, QComboBox, QListWidget {
        background-color: #2c2c2c;  /* Slightly lighter dark grey for list */
        border: none;
        border-radius: 4px;
        outline: none;
        }
        QLineEdit:focus, QComboBox:focus, QListWidget:focus {
            border: 1px solid #00aaff;
        }
        QPushButton {
        background-color: #bfbfbf;  /* Light gray button bg */
        color: #1e1e1e;             /* Dark text on button */
        padding: 2px 2px;          /* Smaller padding */
        border-radius: 4px;         /* Rounded corners with 4px radius */
        font-weight: 400;
        min-width: 80px;            /* Reduced minimum width */
        transition: background-color 0.2s ease, color 0.2s ease;
        }
        QPushButton:hover {
            background-color: #555555;
        }
        QPushButton:pressed {
            background-color: #222222;
        }
        QListWidget::item:selected {
            background-color: #005f87;
            color: #ffffff;
        }
        QScrollBar:vertical {
            background: #2b2b2b;
            width: 12px;
        }
        QScrollBar::handle:vertical {
            background: #555555;
            min-height: 20px;
            border-radius: 4px;
        }
        QScrollBar::handle:vertical:hover {
            background: #888888;
        }
        """
        self.setStyleSheet(modern_stylesheet)

        
    def _toggle_deadline_autorefresh(self, state):
        if state == QtCore.Qt.Checked:
            interval_sec = max(5, int(self.auto_interval.value()))
            self._deadline_timer.start(interval_sec * 1000)
        else:
            self._deadline_timer.stop()

    # ---------------------------
    # Loading jobs (threaded)
    # ---------------------------
    def load_deadline_jobs(self):
        # Avoid overlapping refreshes
        self._deadline_timer.stop()
        self.saved_filter_text = self.search_bar.text()
        self.search_bar.blockSignals(True)
        self.search_bar.clear()
        self.deadline_table.setRowCount(0)
        self.jobs = []

        deadline_bin_dir = os.getenv("DEADLINE_PATH", r"C:\Program Files\Thinkbox\Deadline10\bin")
        self.deadline_cmd = os.path.join(deadline_bin_dir, "deadlinecommand")
        if platform.system() == "Windows" and not self.deadline_cmd.lower().endswith(".exe"):
            if os.path.isfile(self.deadline_cmd + ".exe"):
                self.deadline_cmd += ".exe"

        user = self.user_filter.currentText().strip() or getpass.getuser()

        # disable refresh while loading
        self.refresh_btn.setEnabled(False)

        loader = DeadlineJobLoader(self.deadline_cmd, user)
        loader.jobs_loaded.connect(self._jobs_from_thread)
        loader.error.connect(self._worker_error)
        loader.finished.connect(lambda: self._thread_cleanup(loader))
        loader.start()
        self.threads.append(loader)

    def _thread_cleanup(self, thread):
        # keep list small, and delete finished refs
        try:
            self.threads = [t for t in self.threads if t.isRunning()]
        except Exception:
            self.threads = []

    def _worker_error(self, msg):
        # show minimal message (main thread)
        print("Worker error:", msg)

    def _jobs_from_thread(self, jobs):
        # Called on main thread via signal
        unique = {}
        for job in jobs:
            jobid = job.get("JobId") or job.get("Id") or job.get("ID") or ""
            if jobid not in unique:
                job["__parsed_jobid"] = jobid
                job["__submit_qdate"] = self._parse_job_submit_date(
                    job.get("JobSubmitDateTime", "") or job.get("JobSubmitDate", "")
                )
                unique[jobid] = job
    
        # replace jobs with unique set
        self.jobs = list(unique.values())
    
        # restore search text and enable refresh
        self.search_bar.blockSignals(False)
        try:
            self.search_bar.setText(self.saved_filter_text)
        finally:
            self.refresh_btn.setEnabled(True)
    
        self.apply_deadline_filter()
    
        # restart auto timer if needed
        if self.auto_refresh_chk.isChecked():
            self._deadline_timer.start(self.auto_interval.value() * 1000)


    def _parse_job_submit_date(self, val):
        if not val:
            return None
        try:
            if str(val).isdigit():
                dt = QDateTime.fromSecsSinceEpoch(int(val))
                return dt.date()
            for fmt in ("yyyy-MM-dd hh:mm:ss", "yyyy-MM-ddThh:mm:ss", "yyyy-MM-dd hh:mm", "yyyy-MM-dd"):
                dt = QDateTime.fromString(val, fmt)
                if dt.isValid():
                    return dt.date()
            m = re.search(r"(\d{4}-\d{2}-\d{2})", val)
            if m:
                dt = QDateTime.fromString(m.group(1), "yyyy-MM-dd")
                if dt.isValid():
                    return dt.date()
        except Exception:
            pass
        return None

    # ---------------------------
    # Table population (main thread only)
    # ---------------------------
    def add_deadline_job_row(self, job):
        row = self.deadline_table.rowCount()
        self.deadline_table.insertRow(row)

        name = job.get("Name", "Unknown")
        user = job.get("UserName", "") or job.get("User", "")
        status = job.get("Status", "")
        pool = job.get("Pool", "")
        priority = str(job.get("Priority", ""))
        job_id = job.get("__parsed_jobid", "UNKNOWN")
        raw_frames = job.get("Frames", "")
        frame_numbers = set()

        if isinstance(raw_frames, str):
            parts = re.split(r"[,\s]+", raw_frames.strip())
            for p in parts:
                if "-" in p:
                    try:
                        a, b = p.split("-", 1)
                        frame_numbers.update(range(int(a), int(b) + 1))
                    except:
                        pass
                elif p.isdigit():
                    frame_numbers.add(int(p))

        frame_list = sorted(frame_numbers)
        frame_range = f"{frame_list[0]}-{frame_list[-1]}" if frame_list else ""

        submit_time = job.get("JobSubmitDateTime", "")
        started_time = job.get("JobStartedDateTime", "")
        completed_time = job.get("JobCompletedDateTime", "")
        output_dir = job.get("JobOutputDirectories", "")
        output_file = job.get("JobOutputFileNames", "")
        output_dir = output_dir[0] if isinstance(output_dir, list) and output_dir else output_dir
        output_file = output_file[0] if isinstance(output_file, list) and output_file else output_file
        submit_machine = job.get("JobSubmitMachine", "")

        try:
            completed = int(job.get("JobCompletedTasks", 0))
            total = int(job.get("JobTaskCount", 1))
            progress = int((completed / total) * 100) if total > 0 else 0
        except:
            progress = 0

        columns = [
            name, user, None, status, frame_range, pool,
            priority, submit_time, started_time, completed_time,
            output_dir, output_file, submit_machine, job_id
        ]

        for i, value in enumerate(columns):
            if i == 2:
                pb = QtWidgets.QProgressBar()
                pb.setValue(progress)
                pb.setAlignment(QtCore.Qt.AlignCenter)
                pb.setFormat(f"{progress}%")
                pb.setFixedHeight(16)
                self.deadline_table.setCellWidget(row, i, pb)
            else:
                item = QtWidgets.QTableWidgetItem(value or "")
                item.setTextAlignment(QtCore.Qt.AlignCenter)
                item.setData(QtCore.Qt.UserRole, job_id)
                self.deadline_table.setItem(row, i, item)

    def apply_deadline_filter(self):
        filter_text = self.search_bar.text().lower().strip()
        user_filter_text = (self.user_filter.currentText() or "").lower().strip()
        date_from = self.date_start.date()
        date_to = self.date_end.date()

        self.deadline_table.setRowCount(0)
        for job in getattr(self, "jobs", []):
            name = job.get("Name", "").lower()
            user = (job.get("UserName", "") or job.get("User", "")).lower()
            jobid = (job.get("__parsed_jobid", "") or "").lower()
            submit_qdate = job.get("__submit_qdate", None)
            if not submit_qdate:
                continue
            if not (date_from <= submit_qdate <= date_to):
                continue
            if user_filter_text and user_filter_text not in user:
                continue
            if filter_text and filter_text not in name and filter_text not in user and filter_text not in jobid:
                continue
            self.add_deadline_job_row(job)

    def get_selected_job_ids(self):
        selected = self.deadline_table.selectionModel().selectedRows()
        job_ids = set()
        for row in selected:
            for col in range(self.deadline_table.columnCount()):
                item = self.deadline_table.item(row.row(), col)
                if item and item.data(QtCore.Qt.UserRole):
                    job_ids.add(item.data(QtCore.Qt.UserRole))
                    break
        return list(job_ids)

    def show_deadline_context_menu(self, pos):
        index = self.deadline_table.indexAt(pos)
        if not index.isValid():
            return
        self.deadline_table.selectRow(index.row())
        job_id = self.deadline_table.item(index.row(), 0).data(QtCore.Qt.UserRole)
        if not job_id:
            return
    
        menu = QtWidgets.QMenu(self)
    
        # Apply flat, semi-transparent, modern style
        menu.setWindowFlags(menu.windowFlags() | QtCore.Qt.FramelessWindowHint | QtCore.Qt.NoDropShadowWindowHint)
        menu.setAttribute(QtCore.Qt.WA_TranslucentBackground, True)
        menu.setStyleSheet("""
            QMenu {
                background-color: rgba(40, 40, 40, 180);
                border-radius: 6px;
                padding: 2px;
                color: #ffffff;
            }
            QMenu::item {
                padding: 2px 20px;
                border-radius: 6px;
                background-color: transparent;
            }
            QMenu::item:selected {
                background-color: rgba(255, 255, 255, 50);
                color: #ffffff;
            }
        """)
    
        menu.addAction("ð Suspend", self.suspend_selected_jobs)
        menu.addAction("â¶ï¸ Resume", self.resume_selected_jobs)
        menu.addAction("â Delete", self.delete_selected_jobs)
        menu.addSeparator()
        menu.addAction("ð View Job Info", lambda jid=job_id: self.fetch_and_show_job_info(jid))
    
        menu.exec_(self.deadline_table.viewport().mapToGlobal(pos))


    def _deadline_row_selected(self):
        sels = self.deadline_table.selectionModel().selectedRows()
        if not sels:
            return
        row = sels[0].row()
        job_id = self.deadline_table.item(row, 0).data(QtCore.Qt.UserRole)
        if job_id:
            self.fetch_and_show_job_info(job_id)


    # ---------------------------
    # Job info (threaded)
    # ---------------------------
    def fetch_and_show_job_info(self, job_id):
        # ensure self.deadline_cmd exists
        if not hasattr(self, "deadline_cmd") or not self.deadline_cmd:
            deadline_bin_dir = os.getenv("DEADLINE_PATH", r"C:\Program Files\Thinkbox\Deadline10\bin")
            self.deadline_cmd = os.path.join(deadline_bin_dir, "deadlinecommand")
            if platform.system() == "Windows" and os.path.isfile(self.deadline_cmd + ".exe"):
                self.deadline_cmd += ".exe"

        info_loader = JobInfoLoader(self.deadline_cmd, job_id)
        info_loader.info_loaded.connect(self._show_job_info)
        info_loader.error.connect(self._worker_error)
        info_loader.finished.connect(lambda: self._thread_cleanup(info_loader))
        info_loader.start()
        self.threads.append(info_loader)

    def _show_job_info(self, parsed):
        # Create a modal dialog to show job info
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Job Info")
        dialog.resize(600, 400)
        layout = QtWidgets.QVBoxLayout(dialog)
    
        table = QtWidgets.QTableWidget()
        table.setColumnCount(2)
        table.setHorizontalHeaderLabels(["Field", "Value"])
        table.horizontalHeader().setStretchLastSection(True)
        table.verticalHeader().setVisible(False)
    
        for i, (k, v) in enumerate(sorted(parsed.items())):
            table.insertRow(i)
            table.setItem(i, 0, QtWidgets.QTableWidgetItem(k))
            table.setItem(i, 1, QtWidgets.QTableWidgetItem(v))
    
        layout.addWidget(table)
    
        btn_close = QtWidgets.QPushButton("Close")
        btn_close.clicked.connect(dialog.accept)
        layout.addWidget(btn_close)
    
        dialog.exec_()


    # ---------------------------
    # Run commands (threaded)
    # ---------------------------
    def _run_command_on_jobs(self, command, job_ids):
        if not job_ids:
            return
        if not hasattr(self, "deadline_cmd") or not self.deadline_cmd:
            deadline_bin_dir = os.getenv("DEADLINE_PATH", r"C:\Program Files\Thinkbox\Deadline10\bin")
            self.deadline_cmd = os.path.join(deadline_bin_dir, "deadlinecommand")
            if platform.system() == "Windows" and os.path.isfile(self.deadline_cmd + ".exe"):
                self.deadline_cmd += ".exe"

        # optionally disable action buttons to prevent double-clicks
        self.suspend_btn.setEnabled(False)
        self.resume_btn.setEnabled(False)
        self.delete_btn.setEnabled(False)

        for jid in job_ids:
            runner = CommandRunner(self.deadline_cmd, command, jid)
            runner.finished_running.connect(self._command_finished)
            runner.finished.connect(lambda: self._thread_cleanup(runner))
            runner.start()
            self.threads.append(runner)

    def suspend_selected_jobs(self):
        self._run_command_on_jobs("SuspendJob", self.get_selected_job_ids())
        # refresh after a short delay
        QtCore.QTimer.singleShot(400, self.load_deadline_jobs)

    def resume_selected_jobs(self):
        self._run_command_on_jobs("ResumeJob", self.get_selected_job_ids())
        QtCore.QTimer.singleShot(400, self.load_deadline_jobs)

    def delete_selected_jobs(self):
        self._run_command_on_jobs("DeleteJob", self.get_selected_job_ids())
        QtCore.QTimer.singleShot(400, self.load_deadline_jobs)

    def _command_finished(self, command, success, message):
        # Called on main thread
        print(f"{command} finished: success={success}, msg={message}")
        # re-enable action buttons (could be more nuanced)
        self.suspend_btn.setEnabled(True)
        self.resume_btn.setEnabled(True)
        self.delete_btn.setEnabled(True)
        # optionally show small popup for failures
        if not success:
            QtWidgets.QMessageBox.warning(self, f"{command} failed", message or "Unknown error")



def show_deadline_viewer():
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])
    
    if not hasattr(app, "_deadline_viewer_instance") or app._deadline_viewer_instance is None:
        viewer = DeadlineGUI()
        viewer.show()
        viewer.load_deadline_jobs()
        app._deadline_viewer_instance = viewer
    else:
        viewer = app._deadline_viewer_instance
        viewer.raise_()
        viewer.activateWindow()
    
    return viewer

# Always launch (but only once at a time)
show_deadline_viewer()

]]></script>
  </tool>

  <tool name="RenderViewer0" label="RenderViewer" icon="$PLAB/icons/render.png">
    <script scriptType="python"><![CDATA[import hou
from PySide2 import QtWidgets, QtCore, QtGui
from PySide2.QtCore import QDateTime
import os
import re
import shutil
import getpass
import subprocess
import sys

try:
    import OpenImageIO as oiio
    HAS_OIIO = True
except ImportError:
    HAS_OIIO = False


def get_folder_owner(path):
    try:
        if os.name == 'nt':
            try:
                import win32security
                sd = win32security.GetFileSecurity(path, win32security.OWNER_SECURITY_INFORMATION)
                owner_sid = sd.GetSecurityDescriptorOwner()
                name, domain, _ = win32security.LookupAccountSid(None, owner_sid)
                return f"{domain}\\{name}"
            except ImportError:
                return getpass.getuser()
            except Exception as e:
                print(f"Error getting Windows owner for {path}: {e}")
                return "Unknown"
        else:
            import pwd
            stat_info = os.stat(path)
            return pwd.getpwuid(stat_info.st_uid).pw_name
    except Exception as e:
        print(f"Error getting owner for {path}: {e}")
        return "Unknown"


class RenderBrowser(QtWidgets.QMainWindow):
    def __init__(self, parent=None):
        parent = parent or hou.ui.mainQtWindow()
        super(RenderBrowser, self).__init__(parent)
        self.setWindowTitle("Render Browser")

        # â Normal Windows-style window with Minimize / Maximize / Close
        self.setWindowFlags(QtCore.Qt.Window |
                            QtCore.Qt.WindowMinimizeButtonHint |
                            QtCore.Qt.WindowMaximizeButtonHint |
                            QtCore.Qt.WindowCloseButtonHint)

        self.resize(900, 550)

        # QMainWindow needs a central widget
        central_widget = QtWidgets.QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QtWidgets.QVBoxLayout(central_widget)

        # --- Styling ---
        self.setStyleSheet(""" QWidget {
            background-color: #2b2b2b;
            color: #dddddd;
            font-family: "Segoe UI", "Arial", sans-serif;
            font-size: 8pt;
        } QHeaderView::section {
            background-color: #3c3c3c;
            color: #dddddd;
            padding: 4px;
            border: 1px solid #444;
        } QTableWidget {
            background-color: #2b2b2b;
            gridline-color: #555555;
            alternate-background-color: #3a3a3a;
        } QTableWidget::item:selected {
            background-color: #505F79;
            color: white;
        } QMenu {
            background-color: #2b2b2b;
            color: #dddddd;
            border: 1px solid #444444;
        } QMenu::item:selected {
            background-color: #505F79;
        } QLabel {
            color: #dddddd;
        } QMessageBox {
            background-color: #2b2b2b;
        }""")

        # --- Top path bar ---
        path_layout = QtWidgets.QHBoxLayout()
        self.path_edit = QtWidgets.QLineEdit()
        self.path_edit.setPlaceholderText("Set Render Directory...")
        self.path_edit.setText(self.get_initial_render_path())
        path_layout.addWidget(self.path_edit)

        button_style = """
        QPushButton {
            background-color: #bfbfbf;
            color: #1e1e1e;
            padding: 2px 2px;
            border-radius: 4px;
            font-weight: 400;
        }
        QPushButton:hover { background-color: #555555; }
        QPushButton:pressed { background-color: #222222; }
        """

        browse_button = QtWidgets.QPushButton("Browse")
        browse_button.setStyleSheet(button_style)
        browse_button.clicked.connect(self.browse_render_path)

        set_button = QtWidgets.QPushButton("Set")
        set_button.setStyleSheet(button_style)
        set_button.clicked.connect(self.set_render_path)

        refresh_button = QtWidgets.QPushButton("ð Refresh")
        refresh_button.setStyleSheet(button_style)
        refresh_button.clicked.connect(self.populate_render_table)

        path_layout.addWidget(browse_button)
        path_layout.addWidget(set_button)
        path_layout.addWidget(refresh_button)
        main_layout.addLayout(path_layout)

        # --- Render table ---
        self.render_table = QtWidgets.QTableWidget()
        self.render_table.setColumnCount(8)
        self.render_table.setHorizontalHeaderLabels([
            "Preview", "Render Layer", "Frame Range", "Frame No", "Resolution",
            "Version", "Date & Time", "User"
        ])
        self.render_table.horizontalHeader().setStretchLastSection(True)
        self.render_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.render_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.render_table.verticalHeader().setVisible(False)
        self.render_table.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.render_table.customContextMenuRequested.connect(self.show_render_context_menu)
        self.render_table.cellDoubleClicked.connect(self.handle_render_double_click)

        main_layout.addWidget(self.render_table)

        # Populate after startup
        QtCore.QTimer.singleShot(300, self.populate_render_table)

    def get_initial_render_path(self):
        if hasattr(hou.session, "last_render_path"):
            return os.path.normpath(hou.session.last_render_path)
        return os.path.normpath(os.path.join(hou.getenv("HIP") or "", "render"))

    def set_render_path(self):
        path = os.path.normpath(self.path_edit.text().strip())
        if not os.path.exists(path):
            QtWidgets.QMessageBox.warning(self, "Invalid Path", f"The path does not exist:\n{path}")
            return
        self.path_edit.setText(path)
        hou.session.last_render_path = path
        self.populate_render_table()

    def browse_render_path(self):
        selected = QtWidgets.QFileDialog.getExistingDirectory(self, "Select Render Directory", self.path_edit.text())
        if selected:
            normalized = os.path.normpath(selected)
            self.path_edit.setText(normalized)

    def generate_thumbnail(self, image_path, size=(160, 90)):
        label = QtWidgets.QLabel()
        label.setAlignment(QtCore.Qt.AlignCenter)
        label.setStyleSheet("padding: 2px; background-color: #222222; color: gray;")
        if not os.path.isfile(image_path):
            label.setText("File not found")
            return label

        ext = os.path.splitext(image_path)[1].lower()
        display_path = image_path

        if ext == ".exr" and HAS_OIIO:
            try:
                import tempfile
                buf = oiio.ImageBuf(image_path)
                tmp = tempfile.NamedTemporaryFile(suffix=".png", delete=False)
                display_path = tmp.name
                buf.write(display_path)
            except Exception:
                label.setText("EXR read error")
                return label

        reader = QtGui.QImageReader(display_path)
        reader.setAutoTransform(True)
        image = reader.read()

        if image.isNull():
            label.setText("Unsupported Format")
        else:
            pixmap = QtGui.QPixmap.fromImage(image)
            scaled_pixmap = pixmap.scaled(size[0], size[1], QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation)
            label.setPixmap(scaled_pixmap)

        if ext == ".exr" and HAS_OIIO:
            try:
                os.remove(display_path)
            except:
                pass

        return label

    def populate_render_table(self):
        try:
            self.render_table.setRowCount(0)
            render_dir = self.path_edit.text().strip()
            if not os.path.exists(render_dir):
                return
            version_folders = sorted([f for f in os.listdir(render_dir) if f.lower().startswith('v') and os.path.isdir(os.path.join(render_dir, f))])
            row = 0
            for i, version in enumerate(version_folders):
                version_path = os.path.join(render_dir, version)
                layer_folders = sorted(os.listdir(version_path))
                text_color = QtGui.QColor("#FFFFFF") if i % 2 == 0 else QtGui.QColor("#FFDAB3")
                for layer in layer_folders:
                    layer_path = os.path.join(version_path, layer)
                    if not os.path.isdir(layer_path):
                        continue
                    exr_files = [f for f in os.listdir(layer_path) if os.path.splitext(f)[1].lower() in (".exr", ".jpg", ".jpeg", ".png", ".dpx", ".tif", ".tiff")]
                    if not exr_files:
                        continue
                    exr_files.sort()
                    pattern = re.compile(r"^(.*?)(\d+)\.[^.]+$")
                    matches = [pattern.match(f) for f in exr_files]
                    frame_range = f"{int(matches[0].group(2))}-{int(matches[-1].group(2))}" if matches and all(matches) else f"1-{len(exr_files)}"
                    resolution = "Unknown"
                    try:
                        if HAS_OIIO:
                            img = oiio.ImageInput.open(os.path.join(layer_path, exr_files[0]))
                            if img:
                                spec = img.spec()
                                resolution = f"{spec.width}x{spec.height}"
                                img.close()
                    except Exception:
                        resolution = "Unknown"

                    modified_time = os.path.getmtime(layer_path)
                    datetime_str = QDateTime.fromSecsSinceEpoch(int(modified_time)).toString("yyyy-MM-dd hh:mm")
                    user = get_folder_owner(layer_path)
                    frame_count = str(len(exr_files))
                    self.render_table.insertRow(row)
                    thumb_path = os.path.join(layer_path, exr_files[len(exr_files) // 2])
                    thumb_label = self.generate_thumbnail(thumb_path)
                    self.render_table.setCellWidget(row, 0, thumb_label)
                    row_data = [layer, frame_range, frame_count, resolution, version, datetime_str, user]
                    for col, data in enumerate(row_data):
                        item = QtWidgets.QTableWidgetItem(data)
                        item.setForeground(text_color)
                        item.setData(QtCore.Qt.UserRole, layer_path)
                        item.setTextAlignment(QtCore.Qt.AlignCenter)
                        if col == 0:
                            item.setTextAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)
                        self.render_table.setItem(row, col + 1, item)
                    row += 1

            min_widths = [60, 140, 140, 80, 140, 70, 140, 140]
            for col, width in enumerate(min_widths):
                self.render_table.setColumnWidth(col, width)
                self.render_table.horizontalHeader().setMinimumSectionSize(50)
        except Exception as e:
            print("populate_render_table error:", e)

    def show_render_context_menu(self, pos):
        index = self.render_table.indexAt(pos)
        if not index.isValid():
            return
        row = index.row()
        item = self.render_table.item(row, 1)
        if not item:
            return
        folder_path = item.data(QtCore.Qt.UserRole)
        if not folder_path or not os.path.exists(folder_path):
            return
        menu = QtWidgets.QMenu()
        menu.addAction("ð Open Folder", lambda: self.open_folder(folder_path))
        menu.addAction("ð Copy Path", lambda: QtWidgets.QApplication.clipboard().setText(folder_path))
        menu.addAction("ðï¸ Delete", lambda: self.delete_render_folder(row, folder_path))
        menu.setWindowFlags(menu.windowFlags() | QtCore.Qt.FramelessWindowHint | QtCore.Qt.NoDropShadowWindowHint)
        menu.setAttribute(QtCore.Qt.WA_TranslucentBackground)
        menu.setStyleSheet("""
            QMenu {
                background-color: rgba(40, 40, 40, 220);
                border-radius: 6px;
                padding: 2px;
                color: #ffffff;
            }
            QMenu::item {
                padding: 2px 20px;
                border-radius: 6px;
                background-color: transparent;
            }
            QMenu::item:selected {
                background-color: rgba(255, 255, 255, 50);
                color: #ffffff;
            }
        """)
        menu.exec_(self.render_table.viewport().mapToGlobal(pos))

    def handle_render_double_click(self, row, column):
        layer_item = self.render_table.item(row, 1)
        version_item = self.render_table.item(row, 5)
        if not layer_item or not version_item:
            return
        folder = os.path.normpath(os.path.join(self.path_edit.text(), version_item.text(), layer_item.text()))
        if not os.path.exists(folder):
            QtWidgets.QMessageBox.warning(self, "Not Found", f"Folder not found:\n{folder}")
            return
        try:
            extensions = [".exr", ".jpg", ".jpeg", ".png", ".dpx", ".tif", ".tiff"]
            files = sorted(f for f in os.listdir(folder) if os.path.splitext(f)[1].lower() in extensions)
            pattern = re.compile(r"(.*?)(\d+)\.(exr|jpg|jpeg|png|dpx|tif|tiff)$", re.IGNORECASE)
            matches = [pattern.match(f) for f in files if pattern.match(f)]
            if matches:
                base, start = matches[0].group(1), int(matches[0].group(2))
                end = int(matches[-1].group(2))
                ext = matches[0].group(3).lower()
                padding = len(matches[0].group(2))
                sequence = os.path.join(folder, f"{base}$F{padding}.{ext}")
                try:
                    subprocess.Popen(["mplay", "-f", str(start), str(end), "1", sequence])
                    return
                except FileNotFoundError:
                    QtWidgets.QMessageBox.warning(self, "MPlay Not Found", "MPlay is not installed or not in PATH.")
            mp4s = [os.path.join(folder, f) for f in os.listdir(folder) if f.lower().endswith(".mp4")]
            if mp4s:
                if os.name == 'nt':
                    os.startfile(mp4s[0])
                elif sys.platform == 'darwin':
                    subprocess.Popen(["open", mp4s[0]])
                else:
                    subprocess.Popen(["xdg-open", mp4s[0]])
                return
            self.open_folder(folder)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))

    def delete_render_folder(self, row, path):
        confirm = QtWidgets.QMessageBox.question(self, "Confirm Delete", f"Delete:\n{path}?",
                                                 QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
        if confirm == QtWidgets.QMessageBox.Yes:
            try:
                shutil.rmtree(path)
                self.render_table.removeRow(row)
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "Delete Failed", str(e))

    def open_folder(self, folder):
        if os.name == 'nt':
            os.startfile(folder)
        elif sys.platform == 'darwin':
            subprocess.Popen(['open', folder])
        else:
            subprocess.Popen(['xdg-open', folder])


# -------------------------------
# Launch Helper
# -------------------------------
_render_browser_instance = None

def show_render_browser():
    global _render_browser_instance
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])

    if _render_browser_instance is None:
        _render_browser_instance = RenderBrowser()

        def reset_instance():
            global _render_browser_instance
            _render_browser_instance = None

        # reset when closed/destroyed
        _render_browser_instance.destroyed.connect(reset_instance)

    _render_browser_instance.show()
    _render_browser_instance.raise_()
    _render_browser_instance.activateWindow()

    if not QtWidgets.QApplication.instance():
        app.exec_()


# -------------------------------
# Run
# -------------------------------
show_render_browser()
]]></script>
  </tool>

  <tool name="sop_spiral" label="Spiral" icon="SOP_spiral">
    <helpURL>operator:Sop/spiral</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
      <contextNetType>LOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Curves</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
from soptoolutils import OrientInfo
turns = 3
rad0 = 0.125
rad1 = 1.0
rad = max(rad0, rad1)
height = 0
if hou.ui.orientationUpAxis() == hou.orientUpAxis.Z:
    kwargs['bbox'] = hou.BoundingBox(-rad, -rad, 0, rad, rad, height)
else:
    kwargs['bbox'] = hou.BoundingBox(-rad, 0, -rad, rad, height, rad)
kwargs['parms'] = {
    'turns': turns,
    'height': height,
    'startradius': rad0,
    'radiusincreaseperturn': (rad1-rad0)/turns
    }
soptoolutils.genericTool(kwargs, 'spiral', orient=OrientInfo('orient'))]]></script>
  </tool>

  <tool name="sop_sculpt::2.0" label="Sculpt" icon="SOP_sculpt">
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/sculpt::2.0</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Deform</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
soptoolutils.genericTool(kwargs, 'sculpt::2.0')
]]></script>
  </tool>

  <tool name="sop_constraintnetwork" label="Constraints Network" icon="SOP_constraintnetwork">
    <helpURL>tool:sop_constraintnetwork</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>Managers</toolSubmenu>
    <script scriptType="python"><![CDATA[#import soptoolutils
#soptoolutils.genericTool(kwargs, 'constraintnetwork')
import objecttoolutils
objecttoolutils.constraintnetworkStateToolApply(kwargs)]]></script>
  </tool>

  <tool name="sop_revolve::2.0" label="Revolve" icon="SOP_revolve">
    <helpURL>operator:Sop/revolve?version=2.0</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/revolve::2.0</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons/Topology</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'revolve::2.0')]]></script>
  </tool>

  <tool name="sop_pointweld" label="Point Weld" icon="SOP_pointweld">
    <helpURL>operator:Sop/pointweld</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/pointweld</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Points</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'pointweld')]]></script>
  </tool>

  <tool name="sop_clusterpoints" label="Cluster Points" icon="SOP_clusterpoints">
    <helpURL>operator:Sop/clusterpoints</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/clusterpoints</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Points</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

soptoolutils.genericTool(kwargs, 'clusterpoints')]]></script>
  </tool>

  <tool name="sop_curve::2.0_polygon" label="Curve Polygon" icon="SOP_curve">
    <helpURL>operator:Sop/curve</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/curve::2.0</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Curves</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
import toolutils

scene_viewer = toolutils.activePane(kwargs)
cwd = scene_viewer.pwd()
if (scene_viewer.type() == hou.paneTabType.SceneViewer):
    if (cwd.childTypeCategory() == hou.sopNodeTypeCategory()
        and scene_viewer.isCreateInContext()): # Sop create in context
        # Handle this case specially to have specialized behaviour for putting
        # down a curve generator that is different than other generators
        # since we DO NOT want to choose an initial position.
        geotypes = [hou.geometryType.Primitives]
        current_node = scene_viewer.currentNode()
        if current_node and isinstance(current_node, hou.SopNode):
            current_node.setSelectableTemplateFlag(True)
        node = cwd.createNode('curve::2.0')
        node.moveToGoodPosition()
        node.setDisplayFlag(True)
        node.setCurrent(True, True)
        scene_viewer.enterCurrentNodeState()
    else:
        node = soptoolutils.genericTool(kwargs, 'curve::2.0')
        node.setDisplayFlag(True)
        node.setCurrent(True, True)
else: # Network viewer or Object viewer
    node = soptoolutils.genericTool(kwargs, 'curve::2.0')

if node:
    outputtype_parm = node.parm('outputtype')
    if outputtype_parm:
        outputtype_parm.set(0)
   ]]></script>
  </tool>

  <tool name="sop_polyhinge" label="PolyHinge" icon="SOP_polyhinge">
    <helpURL>operator:Sop/polyhinge</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/polyhinge</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Polygons</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
import stateutils
import toolutils
from sidefx_polyhinge import getPivot

pane = toolutils.activePane(kwargs)
if pane.type() == hou.paneTabType.SceneViewer:
    faces = stateutils.Selector(
        name = "select_polys",
        geometry_types=[hou.geometryType.Primitives],
        prompt="Select primitives to hinge and press Enter to continue.",
        group_parm_name="group",
        input_index=0,
        input_required=True)
    edges = stateutils.Selector(
        name="select_edges",
        geometry_types=[hou.geometryType.Edges],
        prompt="Now select the edge to pivot around and press Enter to complete.",
        group_parm_name="hingeedge",
        input_index=0,
        input_required=False)
        
    container, selections, selectednode = soptoolutils.getGeometrySelections(
        pane, [faces, edges], allow_obj_selection=False
    )
    
    node = stateutils.createFilterSop(
        kwargs, "polyhinge", container, selections
    )
    
    if node:
        if len(selections) <= 1:
            node.parm("pivotmode").set("posanddir")
        else:
            pivot_results = getPivot(node)
            if pivot_results is not None:
                node.parmTuple("hingepivotpos").set(pivot_results["pivot"])
                node.parmTuple("hingepivotdir").set(pivot_results["pivot_dir"])
    
    pane.enterCurrentNodeState()
else:
    soptoolutils.genericTool(kwargs, "polyhinge")]]></script>
  </tool>

  <tool name="sop_curve::2.0_bezier" label="Curve Bezier" icon="SOP_curve">
    <helpURL>operator:Sop/curve</helpURL>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextOpType>Sop/curve::2.0</contextOpType>
    </toolMenuContext>
    <toolSubmenu>Geometry/Curves</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils
import toolutils

scene_viewer = toolutils.activePane(kwargs)
cwd = scene_viewer.pwd()
if (scene_viewer.type() == hou.paneTabType.SceneViewer):
    if (cwd.childTypeCategory() == hou.sopNodeTypeCategory()
        and scene_viewer.isCreateInContext()): # Sop create in context
        # Handle this case specially to have specialized behaviour for putting
        # down a curve generator that is different than other generators
        # since we DO NOT want to choose an initial position.
        geotypes = [hou.geometryType.Primitives]
        current_node = scene_viewer.currentNode()
        if current_node and isinstance(current_node, hou.SopNode):
            current_node.setSelectableTemplateFlag(True)
        node = cwd.createNode('curve::2.0')
        node.moveToGoodPosition()
        node.setDisplayFlag(True)
        node.setCurrent(True, True)
        scene_viewer.enterCurrentNodeState()
    else:
        node = soptoolutils.genericTool(kwargs, 'curve::2.0')
        node.setDisplayFlag(True)
        node.setCurrent(True, True)
else: # Network viewer or Object viewer
    node = soptoolutils.genericTool(kwargs, 'curve::2.0')
    ]]></script>
  </tool>

  <tool name="cacheBrowser" label="CacheBrowser" icon="$XLAB/icons/cache.png">
    <script scriptType="python"><![CDATA[
import os
import sys
import shutil
import subprocess
from functools import partial
import hou

from PySide2 import QtWidgets, QtCore, QtGui


class CacheBrowser(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super(CacheBrowser, self).__init__(parent)
        self.setWindowTitle("Cache Browser")

        # â Normal Windows-style window with Minimize / Maximize / Close
        self.setWindowFlags(QtCore.Qt.Window |
                            QtCore.Qt.WindowMinimizeButtonHint |
                            QtCore.Qt.WindowMaximizeButtonHint |
                            QtCore.Qt.WindowCloseButtonHint)

        self.resize(900, 550)

        # --- Main Layout ---
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.setContentsMargins(2, 2, 2, 2)
        main_layout.setSpacing(2)

        # --- Path Selector ---
        path_layout = QtWidgets.QHBoxLayout()
        self.path_edit = QtWidgets.QLineEdit()
        self.path_edit.setReadOnly(True)

        set_path_btn = QtWidgets.QPushButton("Set Folder")
        set_path_btn.setFixedWidth(100)
        set_path_btn.clicked.connect(self.set_cache_dir)

        path_layout.addWidget(QtWidgets.QLabel("Cache Path:"))
        path_layout.addWidget(self.path_edit, 1)
        path_layout.addWidget(set_path_btn)
        main_layout.addLayout(path_layout)

        # --- Top Bar (Search + Refresh) ---
        top_layout = QtWidgets.QHBoxLayout()
        self.search_bar = QtWidgets.QLineEdit()
        self.search_bar.setPlaceholderText("ð Search caches...")
        self.search_bar.textChanged.connect(self.filter_cache_tree)
        top_layout.addWidget(self.search_bar)

        refresh_btn = QtWidgets.QPushButton("â³ Refresh")
        refresh_btn.setFixedWidth(100)
        refresh_btn.clicked.connect(self.populate_cache_tree)
        top_layout.addWidget(refresh_btn)

        main_layout.addLayout(top_layout)

        # --- Cache Tree ---
        self.cache_tree = QtWidgets.QTreeWidget()
        self.cache_tree.setHeaderLabels(["Cache Name", "Date Modified", "Size"])
        self.cache_tree.setColumnWidth(0, 350)
        self.cache_tree.setColumnWidth(1, 180)
        self.cache_tree.setColumnWidth(2, 120)
        self.cache_tree.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.cache_tree.customContextMenuRequested.connect(self.show_cache_context_menu)
        self.cache_tree.itemDoubleClicked.connect(self.on_item_double_clicked)
        self.cache_tree.setSortingEnabled(True)
        main_layout.addWidget(self.cache_tree, 1)

        # --- Bottom Status ---
        bottom_layout = QtWidgets.QVBoxLayout()
        self.status_label = QtWidgets.QLabel("Ready")
        self.disk_summary_label = QtWidgets.QLabel("")
        bottom_layout.addWidget(self.status_label)
        bottom_layout.addWidget(self.disk_summary_label)
        main_layout.addLayout(bottom_layout)

        # --- Load Settings ---
        self.settings = QtCore.QSettings("PLAB", "CacheBrowser")
        saved_path = self.settings.value("cache_dir", "")

        if saved_path and os.path.exists(saved_path):
            self.cache_dir = os.path.normpath(os.path.abspath(saved_path))
        else:
            hip_path = hou.getenv("HIP")
            default1 = os.path.join(hip_path, "Cache")
            default2 = os.path.join(hip_path, "cache")
            if os.path.exists(default1):
                self.cache_dir = os.path.normpath(os.path.abspath(default1))
            elif os.path.exists(default2):
                self.cache_dir = os.path.normpath(os.path.abspath(default2))
            else:
                self.cache_dir = os.path.normpath(os.path.abspath(default1))

        self.path_edit.setText(self.cache_dir)

        # --- Populate Initial Data ---
        self.populate_cache_tree()
        self.center_on_parent()
        self.apply_dark_theme()

    # -------------------------------
    # Cache Population
    # -------------------------------
    def populate_cache_tree(self):
        cache_dir = self.cache_dir
        self.cache_tree.clear()

        if not os.path.exists(cache_dir):
            self.status_label.setText("No Cache directory found.")
            self.disk_summary_label.setText("")
            return

        total_size_bytes = 0

        for cache_name in os.listdir(cache_dir):
            cache_path = os.path.join(cache_dir, cache_name)
            if os.path.isdir(cache_path):
                last_modified = self.get_last_modified_time(cache_path)
                folder_size_bytes = self.get_folder_size_bytes(cache_path)
                total_size_bytes += folder_size_bytes

                parent_item = QtWidgets.QTreeWidgetItem([
                    cache_name,
                    last_modified,
                    self.format_size(folder_size_bytes)
                ])
                self.cache_tree.addTopLevelItem(parent_item)

                # Add version subfolders
                for version in sorted(os.listdir(cache_path)):
                    version_path = os.path.join(cache_path, version)
                    if os.path.isdir(version_path) and version.startswith("v"):
                        version_size_bytes = self.get_folder_size_bytes(version_path)
                        version_item = QtWidgets.QTreeWidgetItem([
                            version,
                            self.get_last_modified_time(version_path),
                            self.format_size(version_size_bytes)
                        ])
                        parent_item.addChild(version_item)

                # Expand only if more than 1 version exists
                parent_item.setExpanded(parent_item.childCount() > 1)

        # Update summary
        self.status_label.setText("Cache list updated.")
        self.update_disk_summary(cache_dir, total_size_bytes)

    def get_last_modified_time(self, path):
        try:
            mtime = os.path.getmtime(path)
            return QtCore.QDateTime.fromSecsSinceEpoch(int(mtime)).toString("yyyy-MM-dd hh:mm")
        except Exception:
            return "Unknown"

    def get_folder_size_bytes(self, path):
        total = 0
        for root, _, files in os.walk(path):
            for f in files:
                try:
                    total += os.path.getsize(os.path.join(root, f))
                except Exception:
                    pass
        return total

    def format_size(self, size):
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024:
                return f"{size:.1f} {unit}"
            size /= 1024
        return f"{size:.1f} PB"

    def update_disk_summary(self, cache_dir, total_cache_size):
        try:
            usage = shutil.disk_usage(cache_dir)
            free_space = usage.free
            self.disk_summary_label.setText(
                f"ð¦ Total Cache Size: {self.format_size(total_cache_size)} | ð¾ Free Disk Space: {self.format_size(free_space)}"
            )
        except Exception as e:
            self.disk_summary_label.setText(f"Disk usage info unavailable: {e}")

    # -------------------------------
    # Path Setter
    # -------------------------------
    def set_cache_dir(self):
        dir_ = QtWidgets.QFileDialog.getExistingDirectory(self, "Select Cache Directory", self.cache_dir)
        if dir_:
            self.cache_dir = os.path.normpath(os.path.abspath(dir_))
            self.path_edit.setText(self.cache_dir)
            # Save user preference
            self.settings.setValue("cache_dir", self.cache_dir)
            self.populate_cache_tree()

    # -------------------------------
    # Search Filter
    # -------------------------------
    def filter_cache_tree(self, text):
        text = text.lower()
        for i in range(self.cache_tree.topLevelItemCount()):
            parent = self.cache_tree.topLevelItem(i)
            parent_visible = text in parent.text(0).lower()
            child_visible = False
            for j in range(parent.childCount()):
                child = parent.child(j)
                match = text in child.text(0).lower()
                child.setHidden(not match)
                if match:
                    child_visible = True
            parent.setHidden(not (parent_visible or child_visible))

    # -------------------------------
    # Context Menu
    # -------------------------------
    def show_cache_context_menu(self, pos):
        item = self.cache_tree.itemAt(pos)
        if not item:
            return
    
        path = self.get_item_path(item)
    
        menu = QtWidgets.QMenu(self)
    
        # Enable true transparency
        menu.setWindowFlags(menu.windowFlags() | QtCore.Qt.FramelessWindowHint | QtCore.Qt.NoDropShadowWindowHint)
        menu.setAttribute(QtCore.Qt.WA_TranslucentBackground, True)
    
        # Apply flat, rounded, transparent style
        menu.setStyleSheet("""
            QMenu {
                background-color: rgba(40, 40, 40, 180);
                border-radius: 6px;
                padding: 2px;
                color: #ffffff;
            }
            QMenu::item {
                padding: 2px 20px;
                border-radius: 6px;
                background-color: transparent;
            }
            QMenu::item:selected {
                background-color: rgba(255, 255, 255, 50);
                color: #ffffff;
            }
        """)
    
        open_action = menu.addAction("ð Open Folder")
        copy_action = menu.addAction("ð Copy Path")
        delete_action = menu.addAction("ðï¸ Delete Cache")
        override_action = menu.addAction("â¬ Override with Blank")
    
        action = menu.exec_(self.cache_tree.viewport().mapToGlobal(pos))
        if action == open_action:
            self.open_folder(path)
        elif action == copy_action:
            QtWidgets.QApplication.clipboard().setText(path)
            self.status_label.setText("Path copied to clipboard")
        elif action == delete_action:
            self.delete_cache_folder(path)
        elif action == override_action:
            self.override_with_blank(path)

    def get_item_path(self, item):
        parts = []
        while item:
            parts.insert(0, item.text(0).split()[0])
            item = item.parent()
        return os.path.normpath(os.path.abspath(os.path.join(self.cache_dir, *parts)))

    # -------------------------------
    # File Ops
    # -------------------------------
    def open_folder(self, path):
        try:
            if os.path.exists(path):
                if sys.platform == "win32":
                    os.startfile(path)
                elif sys.platform == "darwin":
                    subprocess.Popen(["open", path])
                else:
                    subprocess.Popen(["xdg-open", path])
        except Exception as e:
            print(f"Open folder failed: {e}")

    def delete_cache_folder(self, path):
        reply = QtWidgets.QMessageBox.question(
            self,
            "Delete Cache",
            f"Are you sure you want to delete:\n{path} ?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No
        )
        if reply == QtWidgets.QMessageBox.Yes:
            try:
                shutil.rmtree(path)
                self.populate_cache_tree()
            except Exception as e:
                print(f"Failed to delete cache folder {path}: {e}")

    def override_with_blank(self, path):
        try:
            for root, _, files in os.walk(path):
                for f in files:
                    open(os.path.join(root, f), 'wb').close()
            self.status_label.setText("Cache overridden with blank files.")
        except Exception as e:
            print(f"Failed to override cache: {e}")

    # -------------------------------
    # Double-click opens folder
    # -------------------------------
    def on_item_double_clicked(self, item, column):
        path = self.get_item_path(item)
        self.open_folder(path)

    # -------------------------------
    # Helpers
    # -------------------------------
    def center_on_parent(self):
        if self.parent():
            parent_geom = self.parent().frameGeometry()
            self.move(parent_geom.center() - self.rect().center())
        else:
            screen = QtWidgets.QDesktopWidget().screenGeometry()
            self.move(
                (screen.width() - self.width()) // 2,
                (screen.height() - self.height()) // 2
            )

    def apply_dark_theme(self):
        modern_stylesheet = """
            QWidget {
                background-color: #1e1e1e;
                color: #f0f0f0;
                border-radius: 4px;
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                font-size: 12px;
            }
            QLabel {
                background: transparent;
                border: none;
                color: #aaaaaa;
                font-size: 12px;
                padding: 0px;
            }
            QLineEdit {
                background-color: #2c2c2c;
                border: 1px solid #444;
                border-radius: 4px;
                padding: 0px 0px;
                color: #fff;
            }
            QLineEdit:focus {
                border: 1px solid #888;
                background-color: #333;
            }
            QTreeWidget {
                background-color: #1e1e1e;
                border: none;
                outline: none;
            }
            QTreeWidget::item {
                background-color: transparent;
                margin: 0px 0px;
                padding: 2px;
                border-radius: 0px;
                color: #ddd;
            }
            QTreeWidget::item:selected {
                background-color: #3a6ea5;
                color: #ffffff;
            }
            QTreeWidget::item:hover {
                background-color: #2d2d2d;
                color: #fff;
            }
            QHeaderView::section {
                background-color: #1e1e1e;
                color: #bbbbbb;
                border: none;
                border-bottom: 2px solid #333;
                padding: 2px;
                font-weight: 500;
            }
            QPushButton {
                background-color: #bfbfbf;
                color: #1e1e1e;    
                padding: 2px 2px;
                border-radius: 4px;
                font-weight: 500;
                border: none;
            }
            QPushButton:hover {
                background-color: #505050;
            }
            QPushButton:pressed {
                background-color: #606060;
            }
        """
        self.setStyleSheet(modern_stylesheet)


# -------------------------------
# Launch Helper
# -------------------------------
_cache_browser_instance = None

def show_cache_browser():
    global _cache_browser_instance
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])

    if _cache_browser_instance is None:
        _cache_browser_instance = CacheBrowser()

        def reset_instance():
            global _cache_browser_instance
            _cache_browser_instance = None

        _cache_browser_instance.destroyed.connect(reset_instance)

    _cache_browser_instance.show()
    _cache_browser_instance.raise_()
    _cache_browser_instance.activateWindow()

    if not QtWidgets.QApplication.instance():
        app.exec_()


# -------------------------------
# Run
# -------------------------------
show_cache_browser()
]]></script>
  </tool>

  <tool name="cameraViewer" label="CameraViewer" icon="$XLAB/icons/camera.png">
    <script scriptType="python"><![CDATA[import hou
from PySide2 import QtWidgets, QtCore, QtGui


# Function to recursively find all camera nodes
def find_all_cameras(node):
    cameras = []
    if node.type().name() == "cam":
        cameras.append(node)

    for child in node.children():
        cameras.extend(find_all_cameras(child))

    return cameras


# Custom QListWidgetItem to allow coloring active camera
class CameraListItem(QtWidgets.QListWidgetItem):
    def __init__(self, cam_node):
        super(CameraListItem, self).__init__(cam_node.path())
        self.cam_node = cam_node
        self.update_tooltip()

    def update_tooltip(self):
        try:
            resx = self.cam_node.parm("resx").eval()
            resy = self.cam_node.parm("resy").eval()
            focal = self.cam_node.parm("focal").eval()
            near = self.cam_node.parm("near").eval()
            far = self.cam_node.parm("far").eval()
            tooltip = f"""
            ð· Camera: {self.cam_node.name()}
            Path: {self.cam_node.path()}
            Resolution: {int(resx)} x {int(resy)}
            Focal Length: {focal:.2f}
            Clipping: {near:.2f} - {far:.2f}
            """
            self.setToolTip(tooltip)
        except:
            self.setToolTip(self.cam_node.path())


# Main UI Class
class CameraFinderUI(QtWidgets.QMainWindow):
    def __init__(self, parent=None):
        super(CameraFinderUI, self).__init__(parent)

        self.setWindowTitle("ð¥ Houdini Camera Finder")
        self.resize(900, 550)  # allow resizable instead of fixed size

        # â Enable Minimize / Maximize / Close buttons
        self.setWindowFlags(
            QtCore.Qt.Window |
            QtCore.Qt.WindowMinimizeButtonHint |
            QtCore.Qt.WindowMaximizeButtonHint |
            QtCore.Qt.WindowCloseButtonHint
        )

        # QMainWindow needs a central widget
        central_widget = QtWidgets.QWidget()
        self.setCentralWidget(central_widget)

        # Apply modern dark theme
        self.setStyleSheet("""
            QMainWindow {
                background-color: #2b2b2b;
                color: #dddddd;
                font-family: 'Segoe UI', sans-serif;
                font-size: 12px;
                border-radius: 4px;
            }
            QPushButton {
                background-color: #bfbfbf;
                color: #1e1e1e;
                padding: 1px 1px;
                border-radius: 4px;
                font-weight: 400;
                transition: background-color 0.2s ease, color 0.2s ease;
            }
            QPushButton:hover {
                background-color: #555555;
            }
            QListWidget {
                background-color: #1e1e1e;
                border: 1px solid #5a5a5a;
                border-radius: 4px;
                padding: 2px;
            }
            QListWidget::item {
                border-radius: 4px;
                padding: 2px;
            }
            QListWidget::item:selected {
                background-color: #007acc;
                color: white;
            }
        """)

        # Main layout inside central widget
        layout = QtWidgets.QVBoxLayout(central_widget)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        # ð½ Everything else in your UI stays exactly the same ð½
        # Top button bar
        button_layout = QtWidgets.QHBoxLayout()
        layout.addLayout(button_layout)

        self.find_button = QtWidgets.QPushButton("ð Find All Cameras")
        self.find_button.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        button_layout.addWidget(self.find_button)

        self.refresh_button = QtWidgets.QPushButton("ð Refresh")
        self.refresh_button.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        button_layout.addWidget(self.refresh_button)

        button_layout.addStretch(1)

        # Camera list
        self.camera_list = QtWidgets.QListWidget()
        self.camera_list.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.camera_list.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.camera_list.customContextMenuRequested.connect(self._show_context_menu)
        layout.addWidget(self.camera_list)

        # Connect signals
        self.find_button.clicked.connect(self.populate_camera_list)
        self.refresh_button.clicked.connect(self.populate_camera_list)
        self.camera_list.itemDoubleClicked.connect(self._look_through_camera)

        # Setup hotkeys
        self._setup_shortcuts()

        # Populate on startup
        self.populate_camera_list()

    # ----------------------------
    # HOTKEYS
    # ----------------------------
    def _setup_shortcuts(self):
        QtWidgets.QShortcut(QtGui.QKeySequence("Esc"), self, activated=self.close)
        QtWidgets.QShortcut(QtGui.QKeySequence("Return"), self,
                            activated=lambda: self._look_through_selected())
        QtWidgets.QShortcut(QtGui.QKeySequence("Del"), self,
                            activated=self._delete_selected_cameras)
        QtWidgets.QShortcut(QtGui.QKeySequence("PageDown"), self,
                            activated=self._next_camera)
        QtWidgets.QShortcut(QtGui.QKeySequence("PageUp"), self,
                            activated=self._prev_camera)

    def _look_through_selected(self):
        selected = self.camera_list.selectedItems()
        if selected:
            self._look_through_camera(selected[0])

    def _next_camera(self):
        row = self.camera_list.currentRow()
        if row < self.camera_list.count() - 1:
            self.camera_list.setCurrentRow(row + 1)
            self._look_through_selected()

    def _prev_camera(self):
        row = self.camera_list.currentRow()
        if row > 0:
            self.camera_list.setCurrentRow(row - 1)
            self._look_through_selected()

    # ----------------------------
    # CORE FUNCTIONS
    # ----------------------------
    def populate_camera_list(self):
        self.camera_list.clear()

        root = hou.node("/obj")
        if not root:
            QtWidgets.QMessageBox.warning(self, "Error", "Root /obj node not found.")
            return

        cameras = find_all_cameras(root)

        if not cameras:
            self.camera_list.addItem("No cameras found.")
            return

        # find active camera
        active_cam = None
        scene_viewer = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer)
        if scene_viewer:
            viewport = scene_viewer.curViewport()
            active_cam = viewport.camera()

        for cam in cameras:
            item = CameraListItem(cam)
            if active_cam and cam == active_cam:
                item.setForeground(QtGui.QBrush(QtGui.QColor("lime")))  # highlight active cam
                item.setText(f"â­ {cam.path()}")
            self.camera_list.addItem(item)

    def _show_context_menu(self, pos):
        menu = QtWidgets.QMenu()
        selected_items = self.camera_list.selectedItems()
        if selected_items:
            menu.addAction("ð Copy Path(s)", self._copy_selected_paths)
            menu.addAction("ð Look Through Camera", lambda: self._look_through_camera(selected_items[0]))
            menu.addAction("ð Delete Camera(s)", self._delete_selected_cameras)
            menu.addAction("ð Select in Network Editor", self._select_in_network)
            menu.addAction("ð¯ Set Camera Parm on Selected Node(s)", lambda: self._set_camera_parm(selected_items[0]))

        menu.setWindowFlags(menu.windowFlags() | QtCore.Qt.FramelessWindowHint | QtCore.Qt.NoDropShadowWindowHint)
        menu.setAttribute(QtCore.Qt.WA_TranslucentBackground)
        menu.setStyleSheet("""
            QMenu {
                background-color: rgba(40, 40, 40, 220);
                border: 1px solid rgba(90, 90, 90, 150);
                border-radius: 6px;
                padding: 2px;
            }
            QMenu::item {
                background-color: transparent;
                padding: 2px 20px;
                border-radius: 6px;
                color: #dddddd;
            }
            QMenu::item:selected {
                background-color: rgba(0, 122, 204, 150);
                color: white;
            }
        """)
        menu.exec_(self.camera_list.viewport().mapToGlobal(pos))

    def _copy_selected_paths(self):
        paths = [item.text().replace("â­ ", "") for item in self.camera_list.selectedItems()]
        QtWidgets.QApplication.clipboard().setText("\n".join(paths))

    def _look_through_camera(self, item):
        cam_path = item.text().replace("â­ ", "")
        cam_node = hou.node(cam_path)
        if not cam_node:
            return
        try:
            scene_viewer = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer)
            if scene_viewer:
                viewport = scene_viewer.curViewport()
                viewport.setCamera(cam_node)
                self.populate_camera_list()
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Error", f"Failed to set viewport camera:\n{e}")

    def _delete_selected_cameras(self):
        for item in self.camera_list.selectedItems():
            cam_path = item.text().replace("â­ ", "")
            cam_node = hou.node(cam_path)
            if not cam_node:
                continue

            parent = cam_node.parent()
            if parent and parent.path() != "/obj":
                # â Delete parent subnet if not in /obj
                parent.destroy()
            else:
                # â Delete only camera if directly under /obj
                if cam_node.type().name() == "cam":
                    cam_node.destroy()

        self.populate_camera_list()


    def _select_in_network(self):
        nodes = [hou.node(item.text().replace("â­ ", "")) for item in self.camera_list.selectedItems()]
        nodes = [n for n in nodes if n]
        if nodes:
            hou.clearAllSelected()
            for n in nodes:
                n.setSelected(True, clear_all_selected=False)
            pane = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
            if pane:
                pane.homeToSelection()

    def _set_camera_parm(self, item):
        cam_path = item.text().replace("â­ ", "")
        cam_node = hou.node(cam_path)
        if not cam_node:
            return

        selected_nodes = hou.selectedNodes()
        if not selected_nodes:
            QtWidgets.QMessageBox.information(self, "No Node Selected",
                                              "Please select one or more nodes in the Network Editor.")
            return

        success = False
        for node in selected_nodes:
            parm = node.parm("camera")
            if parm:
                parm.set(cam_node.path())
                success = True

        if success:
            QtWidgets.QMessageBox.information(self, "Success",
                                              f"Camera set to {cam_node.path()} on selected node(s).")
        else:
            QtWidgets.QMessageBox.warning(self, "No Camera Parm Found",
                                          "None of the selected nodes have a 'camera' parameter.")


# --------------------------
# Global instance + launcher
# --------------------------
_camera_finder_instance = None

def show_camera_finder():
    global _camera_finder_instance

    # If already open â just focus it
    if _camera_finder_instance is not None:
        try:
            _camera_finder_instance.raise_()
            _camera_finder_instance.activateWindow()
            return
        except RuntimeError:
            # Old reference is dead â reset
            _camera_finder_instance = None

    # Otherwise create new
    _camera_finder_instance = CameraFinderUI(hou.ui.mainQtWindow())
    _camera_finder_instance.show()

    
show_camera_finder()    ]]></script>
  </tool>

  <tool name="saveFile++" label="SaveFile++" icon="$XLAB/icons/save++.png">
    <script scriptType="python"><![CDATA[import os
import re
import hou

def save_incremental_hip():
    """Save the current Houdini hip file incrementally (v001, v002, ...) 
    without overwriting existing files."""
    
    current_path = hou.hipFile.path()
    hip_dir = hou.getenv("HIP")

    # If unsaved file, start at v001
    if current_path == "untitled.hip" or not current_path:
        new_path = os.path.join(hip_dir, "untitled_v001.hip")
        hou.hipFile.save(new_path)
        print(f"File saved as {new_path}")
        return

    dir_path = os.path.dirname(current_path)
    base_name = os.path.basename(current_path)
    name, ext = os.path.splitext(base_name)

    # Look for version pattern _v### at the end
    match = re.search(r"(.*_v)(\d{3})$", name, re.IGNORECASE)
    if match:
        prefix = match.group(1)
        version_num = int(match.group(2)) + 1
    else:
        prefix = f"{name}_v"
        version_num = 1

    # Find the next available version to avoid overwriting
    while True:
        new_base = f"{prefix}{version_num:03d}{ext}"
        new_path = os.path.join(dir_path, new_base)
        if not os.path.exists(new_path):
            break
        version_num += 1

    # Save the new hip file
    hou.hipFile.save(new_path.replace("\\", "/"))
#    print(f"File saved as {new_path}")

# Run the function
save_incremental_hip()
]]></script>
  </tool>

  <tool name="filesBrowser" label="FilesBrowser" icon="$XLAB/icons/filebrowser.png">
    <script scriptType="python"><![CDATA[import os, sys, re, subprocess, datetime
from functools import partial
import hou
from PySide2 import QtWidgets, QtCore, QtGui
from PySide2.QtGui import QIcon
from PySide2.QtWidgets import QLabel, QMessageBox, QStyle

XLAB_PATH = os.environ.get("XLAB", "")
HIP_ICON_PATH = os.path.join(XLAB_PATH, "icons", "hipicon.png")

class BrowserTool(QtWidgets.QWidget):
    MAX_RECENT = 10

    def __init__(self, parent=None):
        super(BrowserTool, self).__init__(parent)
        self.settings = QtCore.QSettings("YourStudio", "HoudiniBrowser")
        self.base_sp_path = self.settings.value("browser/base_path", "")
        self.browser_combos = {}

        recent_files = self.settings.value("browser/recent_files", [])
        if isinstance(recent_files, str):
            self.recent_files = [recent_files]
        elif isinstance(recent_files, list):
            self.recent_files = recent_files
        else:
            self.recent_files = []

    def create_browser_page(self):
        page = QtWidgets.QWidget()
        layout = QtWidgets.QVBoxLayout(page)
        layout.setContentsMargins(0, 0, 0, 0)

        # --- Base Path Row ---
        path_layout = QtWidgets.QHBoxLayout()
        self.base_path_edit = QtWidgets.QLineEdit(self.base_sp_path)
        browse_btn = QtWidgets.QPushButton("Browse")
        browse_btn.setAutoDefault(False)
        browse_btn.setDefault(False)
        browse_btn.clicked.connect(self._browser_browse_base_path)
        path_layout.addWidget(QLabel("Base Path:"))
        path_layout.addWidget(self.base_path_edit)
        path_layout.addWidget(browse_btn)
        layout.addLayout(path_layout)

        grid = QtWidgets.QGridLayout()
        grid.setSpacing(0)

        # --- Dropdown Row (Single Line) ---
        labels = ["Project Type", "Project", "Shots", "Sequence", "Shot No", "Task"]
        combos = {}

        combo_layout = QtWidgets.QHBoxLayout()
        combo_layout.setSpacing(2)

        for idx, label in enumerate(labels):
            wrapper = QtWidgets.QVBoxLayout()
            wrapper.setSpacing(2)

            lbl = QtWidgets.QLabel(f"{label}:")
            lbl.setStyleSheet("color: white; font-weight: bold;")

            cb = QtWidgets.QComboBox()
            cb.setEditable(False)
            cb.currentIndexChanged.connect(partial(self._browser_combo_changed, idx))

            if label == "Shot No":
                cb.setMinimumWidth(250)
            else:
                cb.setMinimumWidth(20)

            combos[idx] = cb
            wrapper.addWidget(lbl)
            wrapper.addWidget(cb)
            combo_layout.addLayout(wrapper)

        self.browser_combos = combos
        layout.addLayout(combo_layout)

        # --- Path display and buttons ---
        row = QtWidgets.QHBoxLayout()
        row.setContentsMargins(2, 2, 2, 2)
        row.setSpacing(2)

        self.browser_path_display = QtWidgets.QLineEdit()
        self.browser_path_display.setPlaceholderText("Type or paste a folder/file path and press Enter")
        self.browser_path_display.returnPressed.connect(self._browser_path_entered)
        row.addWidget(self.browser_path_display)

        back_btn = QtWidgets.QPushButton("Back")
        back_btn.setAutoDefault(False)
        back_btn.setDefault(False)
        back_btn.clicked.connect(self._browser_go_back)
        row.addWidget(back_btn)

        set_btn = QtWidgets.QPushButton("Set")
        set_btn.setAutoDefault(False)
        set_btn.setDefault(False)
        set_btn.clicked.connect(self._browser_save_selection)
        row.addWidget(set_btn)

        open_btn = QtWidgets.QPushButton("Open Folder")
        open_btn.setAutoDefault(False)
        open_btn.setDefault(False)
        open_btn.clicked.connect(self._browser_open_selected)
        row.addWidget(open_btn)

        layout.addLayout(row)

        # --- File list with Recent files below ---
        file_column = QtWidgets.QVBoxLayout()

        # Files (with Date Modified)
        file_column.addWidget(QLabel("Files:"))

        self.browser_file_list = QtWidgets.QTreeWidget()
        self.browser_file_list.setColumnCount(2)
        self.browser_file_list.setHeaderLabels(["Name", "Date Modified"])
        self.browser_file_list.setHeaderHidden(True)   # â hide labels
        self.browser_file_list.setAlternatingRowColors(True)
        self.browser_file_list.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.browser_file_list.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.browser_file_list.itemDoubleClicked.connect(self._browser_file_double_clicked)
        self.browser_file_list.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.browser_file_list.customContextMenuRequested.connect(self._show_file_context_menu)
        self.browser_file_list.header().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.browser_file_list.header().setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)

        file_column.addWidget(self.browser_file_list, stretch=3)

        # Recent Files
        file_column.addWidget(QLabel("Recent Files:"))
        self.recent_file_list = QtWidgets.QListWidget()
        self.recent_file_list.setAlternatingRowColors(True)
        self.recent_file_list.itemDoubleClicked.connect(self._recent_file_double_clicked)
        file_column.addWidget(self.recent_file_list, stretch=1)

        layout.addLayout(file_column)

        # Populate UI
        self._browser_populate_top()
        self._populate_recent_files()

        # Restore last selected path
        saved = self.settings.value("browser/selected_path", "")
        if saved and os.path.isdir(saved):
            QtCore.QTimer.singleShot(100, lambda p=saved: self._browser_restore_from_path(p))

        return page

    # ---------------- Context menu ----------------
    def _show_file_context_menu(self, position):
        selected_items = self.browser_file_list.selectedItems()
        if not selected_items:
            return

        menu = QtWidgets.QMenu()

        menu.setWindowFlags(menu.windowFlags() | QtCore.Qt.FramelessWindowHint | QtCore.Qt.NoDropShadowWindowHint)
        menu.setAttribute(QtCore.Qt.WA_TranslucentBackground, True)
        menu.setStyleSheet("""
            QMenu {
                background-color: rgba(40, 40, 40, 220);
                border-radius: 6px;
                padding: 2px;
                color: #ffffff;
            }
            QMenu::item {
                padding: 2px 20px;
                border-radius: 6px;
                background-color: transparent;
            }
            QMenu::item:selected {
                background-color: rgba(255, 255, 255, 50);
                color: #ffffff;
            }
        """)

        open_action = menu.addAction("Open")
        open_ext_action = menu.addAction("Open in External Houdini")
        import_action = menu.addAction("Import")
        import_camera_action = menu.addAction("Import Camera")
        delete_action = menu.addAction("Delete")

        action = menu.exec_(self.browser_file_list.viewport().mapToGlobal(position))
        if not action:
            return

        # Resolve selected paths from UserRole
        paths = []
        for it in selected_items:
            p = it.data(0, QtCore.Qt.UserRole)
            if p and p != "__back__":
                paths.append(p)

        if not paths:
            return

        if action == open_action:
            if len(paths) == 1 and paths[0].lower().endswith(".hip"):
                self._open_hip_file(paths[0])
            else:
                QtWidgets.QMessageBox.information(self, "Open File", "Please select exactly one .hip file to open.")

        elif action == open_ext_action:
            if len(paths) == 1 and paths[0].lower().endswith(".hip"):
                self._open_in_external_houdini(paths[0])
            else:
                QtWidgets.QMessageBox.warning(self, "Invalid Selection", "Select exactly one .hip file to open externally.")

        elif action == import_action:
            self._import_files(paths)

        elif action == import_camera_action:
            abc_files = [f for f in paths if f.lower().endswith(".abc")]
            if abc_files:
                self._import_cameras(abc_files)
            else:
                QtWidgets.QMessageBox.information(self, "Import Camera", "No .abc files selected for importing as camera.")

        elif action == delete_action:
            self._delete_files(paths)

    # ---------------- File open helpers ----------------
    def _open_hip_file(self, path):
        if os.path.isfile(path) and path.lower().endswith(".hip"):
            try:
                hou.hipFile.load(path.replace('\\', '/'))
                self._add_to_recent(path)
            except Exception as e:
                print("Error loading hip file:", e)
                hou.ui.displayMessage(f"Error loading file:\n{e}")
        else:
            QMessageBox.warning(self, "Invalid File", "Only .hip files can be opened.")

    def _open_in_external_houdini(self, path):
        if not os.path.isfile(path) or not path.lower().endswith(".hip"):
            QMessageBox.warning(self, "Invalid File", "Only .hip files can be opened in external Houdini.")
            return

        houdini_versions = []
        hfs_path = os.environ.get("HFS")
        if hfs_path:
            houdini_exec = os.path.join(hfs_path, "bin", "houdini.exe" if sys.platform.startswith("win") else "houdini")
            if os.path.isfile(houdini_exec):
                houdini_versions.append((hfs_path, houdini_exec))

        import glob

        if sys.platform.startswith("win"):
            pattern = r"C:\Program Files\Side Effects Software\Houdini *\bin\houdini.exe"
            for f in glob.glob(pattern):
                if (hfs_path is None) or (os.path.dirname(os.path.dirname(f)) != hfs_path):
                    houdini_versions.append((os.path.dirname(os.path.dirname(f)), f))
        elif sys.platform.startswith("linux"):
            pattern = "/opt/hfs*/bin/houdini"
            for f in glob.glob(pattern):
                if (hfs_path is None) or (os.path.dirname(os.path.dirname(f)) != hfs_path):
                    houdini_versions.append((os.path.dirname(os.path.dirname(f)), f))
        elif sys.platform.startswith("darwin"):
            pattern = "/Applications/Houdini */Houdini.app/Contents/MacOS/houdini"
            for f in glob.glob(pattern):
                if (hfs_path is None) or (os.path.dirname(os.path.dirname(f)) != hfs_path):
                    houdini_versions.append((os.path.dirname(os.path.dirname(f)), f))

        if not houdini_versions:
            QMessageBox.critical(self, "Houdini Not Found", "Could not find any Houdini installations.")
            return

        if len(houdini_versions) == 1:
            exec_path = houdini_versions[0][1]
            try:
                subprocess.Popen([exec_path, path], shell=sys.platform.startswith("win"))
            except Exception as e:
                QMessageBox.critical(self, "Launch Failed", f"Could not launch Houdini:\n{e}")
            return

        items = [os.path.basename(v[0]) for v in houdini_versions]
        item, ok = QtWidgets.QInputDialog.getItem(self, "Select Houdini Version",
                                                  "Choose Houdini version to open:", items, 0, False)
        if ok and item:
            for base, exec_path in houdini_versions:
                if os.path.basename(base) == item:
                    try:
                        subprocess.Popen([exec_path, path], shell=sys.platform.startswith("win"))
                    except Exception as e:
                        QMessageBox.critical(self, "Launch Failed", f"Could not launch Houdini:\n{e}")
                    break

    def _import_files(self, file_list):
        obj = hou.node("/obj")
        for path in file_list:
            if not os.path.isfile(path):
                continue

            filename = os.path.basename(path)
            name_no_ext = os.path.splitext(filename)[0]
            ext = os.path.splitext(filename)[1].lower()
            safe_name = self._sanitize_node_name(name_no_ext)

            try:
                geo_node = obj.createNode("geo", node_name=safe_name, run_init_scripts=False, force_valid_node_name=True)

                if ext == ".abc":
                    alembic_node = geo_node.createNode("alembic", node_name=safe_name)
                    alembic_node.parm("fileName").set(path.replace('\\', '/'))
                else:
                    file_node = geo_node.createNode("file", node_name="file1")
                    file_node.parm("file").set(path.replace('\\', '/'))

                geo_node.layoutChildren()
                self._add_to_recent(path)

            except Exception as e:
                print(f"Import error for {path}:", e)
                hou.ui.displayMessage(f"Failed to import file:\n{path}\n\n{e}")

    def _import_cameras(self, file_list):
        for path in file_list:
            if not os.path.isfile(path) or not path.lower().endswith(".abc"):
                QMessageBox.warning(self, "Invalid File", f"Only .abc files can be imported as cameras:\n{path}")
                continue

            name_no_ext = os.path.splitext(os.path.basename(path))[0]
            safe_name = self._sanitize_node_name(name_no_ext)

            try:
                obj = hou.node("/obj")
                archive_node = obj.createNode(
                    "alembicarchive",
                    node_name=safe_name,
                    run_init_scripts=False,
                    force_valid_node_name=True
                )
                archive_node.parm("fileName").set(path.replace('\\', '/'))
                archive_node.parm("buildHierarchy").pressButton()
                archive_node.layoutChildren()
                self._add_to_recent(path)

            except Exception as e:
                print(f"Import camera error for {path}:", e)
                hou.ui.displayMessage(f"Failed to import camera:\n{path}\n\n{e}")

    def _delete_files(self, file_list):
        confirm = QMessageBox.question(
            self,
            "Delete Files",
            "Are you sure you want to delete these files?\n" + "\n".join(file_list),
            QMessageBox.Yes | QMessageBox.No
        )
        if confirm == QMessageBox.Yes:
            for path in file_list:
                try:
                    os.remove(path)
                except Exception as e:
                    QMessageBox.critical(self, "Delete Failed", f"Could not delete file {path}:\n{e}")
            self._browser_populate_files(self.browser_path_display.text().strip())

    def _save_versioned_hip(self):
        shot = self.browser_combos[4].currentText().strip()
        task = self.browser_combos[5].currentText().strip()
        base_path = self.browser_path_display.text().strip()

        if not shot or not task:
            QMessageBox.warning(self, "Missing Info", "Please select both Shot No and Task.")
            return

        if not os.path.isdir(base_path):
            QMessageBox.warning(self, "Invalid Path", "Target directory is invalid.")
            return

        base_name = f"{shot}_{task}"
        existing = [f for f in os.listdir(base_path) if re.match(rf"{re.escape(base_name)}_v\d{{3}}\.hip", f)]

        version = 1
        if existing:
            versions = [int(re.search(r"_v(\d{3})\.hip", f).group(1)) for f in existing]
            version = max(versions) + 1

        filename = f"{base_name}_v{version:03d}.hip"
        full_path = os.path.join(base_path, filename)

        try:
            hou.hipFile.save(full_path.replace('\\', '/'))
            QMessageBox.information(self, "Saved", f"Scene saved as:\n{filename}")
            self._add_to_recent(full_path)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save file:\n{e}")

    def _browser_browse_base_path(self):
        folder = QtWidgets.QFileDialog.getExistingDirectory(self, "Select Base Path", self.base_path_edit.text())
        if folder:
            self.base_path_edit.setText(folder)
            self.base_sp_path = folder
            self.settings.setValue("browser/base_path", folder)
            self.settings.sync()
            self._browser_populate_top()

    def _browser_go_back(self):
        current_path = self.browser_path_display.text().strip()
        if not current_path:
            return
        parent_path = os.path.dirname(current_path)
        if os.path.isdir(parent_path):
            self.browser_path_display.setText(parent_path)
            self._browser_populate_files(parent_path)

    def _browser_populate_top(self):
        base = self.base_path_edit.text().strip()
        try:
            if os.path.isdir(base):
                items = sorted([d for d in os.listdir(base) if os.path.isdir(os.path.join(base, d))])
                cb = self.browser_combos[0]
                cb.clear()
                cb.addItem("")
                for it in items:
                    cb.addItem(it)
                for i in range(1, 6):
                    self.browser_combos[i].clear()
                self.browser_path_display.setText(base)
        except Exception as e:
            print("Browser top populate error:", e)

    # ---------------- Core: populate QTreeWidget ----------------
    def _browser_populate_files(self, path):
        style = QtWidgets.QApplication.style()
    
        self.browser_file_list.clear()
        try:
            if not os.path.isdir(path):
                return
    
            # Back row
            back_item = QtWidgets.QTreeWidgetItem(["â¬ï¸  Back", ""])
            back_item.setData(0, QtCore.Qt.UserRole, "__back__")
            font = back_item.font(0)
            font.setBold(True)
            back_item.setFont(0, font)
            back_item.setFirstColumnSpanned(True)
            self.browser_file_list.addTopLevelItem(back_item)
    
            entries = sorted(os.listdir(path), key=str.lower)
    
            dirs = [e for e in entries if os.path.isdir(os.path.join(path, e))]
            files = [e for e in entries if os.path.isfile(os.path.join(path, e))]
    
            # Add directories with modified date
            for e in dirs:
                full_path = os.path.join(path, e)
                try:
                    mtime = os.path.getmtime(full_path)
                    date_str = datetime.datetime.fromtimestamp(mtime).strftime("%Y-%m-%d %H:%M")
                except Exception:
                    date_str = ""
    
                item = QtWidgets.QTreeWidgetItem([e, date_str])
                item.setIcon(0, style.standardIcon(QStyle.SP_DirIcon))
                item.setData(0, QtCore.Qt.UserRole, full_path)
                self.browser_file_list.addTopLevelItem(item)
    
            # Add files with modified date
            for e in files:
                full_path = os.path.join(path, e)
                try:
                    mtime = os.path.getmtime(full_path)
                    date_str = datetime.datetime.fromtimestamp(mtime).strftime("%Y-%m-%d %H:%M")
                except Exception:
                    date_str = ""
    
                item = QtWidgets.QTreeWidgetItem([e, date_str])
    
                if e.lower().endswith(".hip") and os.path.exists(HIP_ICON_PATH):
                    item.setIcon(0, QtGui.QIcon(HIP_ICON_PATH))
                else:
                    item.setIcon(0, style.standardIcon(QStyle.SP_FileIcon))
    
                item.setData(0, QtCore.Qt.UserRole, full_path)
                self.browser_file_list.addTopLevelItem(item)
    
        except Exception as e:
            print("browser populate files error:", e)


    def _browser_combo_changed(self, idx, text=None):
        try:
            base_path = self.base_path_edit.text().strip()
            if not base_path or not os.path.isdir(base_path):
                return

            parts = []
            for i in range(0, idx + 1):
                txt = self.browser_combos[i].currentText().strip()
                if txt:
                    parts.append(txt)
                else:
                    break

            path = os.path.join(base_path, *parts) if parts else base_path
            path = os.path.normpath(path)

            next_idx = idx + 1
            if next_idx < len(self.browser_combos):
                cb = self.browser_combos[next_idx]
                cb.clear()
                if os.path.isdir(path):
                    items = sorted([d for d in os.listdir(path) if os.path.isdir(os.path.join(path, d))])
                    cb.addItem("")
                    cb.addItems(items)

            deepest_parts = []
            for i in range(len(self.browser_combos)):
                t = self.browser_combos[i].currentText().strip()
                if t:
                    deepest_parts.append(t)
                else:
                    break

            final_path = os.path.join(base_path, *deepest_parts) if deepest_parts else base_path
            final_path = os.path.normpath(final_path)
            self.browser_path_display.setText(final_path)
            self._browser_populate_files(final_path)

        except Exception as e:
            print("browser combo change error:", e)

    def _browser_path_entered(self):
        path = self.browser_path_display.text().strip()
        if os.path.isdir(path):
            self._browser_populate_files(path)
        elif os.path.isfile(path):
            # Open the file directly based on extension
            ext = os.path.splitext(path)[1].lower()
            if ext == ".hip":
                self._open_hip_file(path)
            elif ext == ".abc":
                self._import_files([path])
            else:
                self._import_files([path])
            # Also refresh the containing folder in the tree
            folder = os.path.dirname(path)
            if os.path.isdir(folder):
                self.browser_path_display.setText(folder)
                self._browser_populate_files(folder)
        else:
            QMessageBox.warning(self, "Invalid Path", "The entered path does not exist.")

    def _browser_save_selection(self):
        path = self.browser_path_display.text().strip()
        if not path:
            return
        if not os.path.isdir(path):
            QMessageBox.warning(self, "Invalid Path", "Selected path does not exist.")
            return
        self.settings.setValue("browser/selected_path", path)
        self.settings.sync()
        QMessageBox.information(self, "Saved", f"Path saved:\n{path}")

    def _browser_open_selected(self):
        path = self.browser_path_display.text().strip()
        if path and os.path.isdir(path):
            if os.name == 'nt':
                os.startfile(path)
            elif sys.platform == 'darwin':
                subprocess.Popen(['open', path])
            else:
                subprocess.Popen(['xdg-open', path])
        else:
            QMessageBox.warning(self, "Not Found", "Selected path not found.")

    def _browser_restore_from_path(self, fullpath):
        try:
            fullpath = os.path.normpath(fullpath)
            base = os.path.normpath(self.base_sp_path)
            if not fullpath.startswith(base):
                return
            rel = os.path.relpath(fullpath, base)
            parts = rel.split(os.sep)
            for i, p in enumerate(parts):
                if i > 5:
                    break
                cb = self.browser_combos[i]
                if cb.count() == 0 and i == 0:
                    self._browser_populate_top()
                idx = cb.findText(p)
                if idx >= 0:
                    cb.setCurrentIndex(idx)
            self.browser_path_display.setText(fullpath)
            self._browser_populate_files(fullpath)
        except Exception as e:
            print("browser restore error:", e)

    def _sanitize_node_name(self, name):
        name = re.sub(r'\W', '_', name)
        if not re.match(r'^[A-Za-z_]', name):
            name = '_' + name
        return name

    def _browser_file_double_clicked(self, item, column):
        # QTreeWidgetItem: data is stored in column 0
        if item.data(0, QtCore.Qt.UserRole) == "__back__":
            self._browser_go_back()
            return

        path = item.data(0, QtCore.Qt.UserRole)
        if not path:
            return

        if os.path.isdir(path):
            self.browser_path_display.setText(path)
            self._browser_populate_files(path)
            return

        ext = os.path.splitext(path)[1].lower()
        name_no_ext = os.path.splitext(os.path.basename(path))[0]
        safe_name = self._sanitize_node_name(name_no_ext)

        try:
            if ext == ".hip":
                hou.hipFile.load(path.replace('\\', '/'))
            elif ext == ".abc":
                obj = hou.node("/obj")
                geo_node = obj.createNode("geo", node_name=safe_name,
                                          run_init_scripts=False, force_valid_node_name=True)
                alembic_node = geo_node.createNode("alembic", node_name=safe_name)
                alembic_node.parm("fileName").set(path.replace('\\', '/'))
                geo_node.layoutChildren()
            else:
                obj = hou.node("/obj")
                geo_node = obj.createNode("geo", node_name=safe_name,
                                          run_init_scripts=False, force_valid_node_name=True)
                file_node = geo_node.createNode("file", node_name="file1")
                file_node.parm("file").set(path.replace('\\', '/'))
                geo_node.layoutChildren()

            self._add_to_recent(path)

        except Exception as e:
            print(f"Error opening file: {e}")
            try:
                hou.ui.displayMessage(f"Error opening file:\n{e}")
            except:
                pass

    # ---------------- Recent ----------------
    def _add_to_recent(self, filepath):
        filepath = os.path.normpath(filepath)
        if filepath in self.recent_files:
            self.recent_files.remove(filepath)
        self.recent_files.insert(0, filepath)
        if len(self.recent_files) > self.MAX_RECENT:
            self.recent_files = self.recent_files[:self.MAX_RECENT]
        self.settings.setValue("browser/recent_files", self.recent_files)
        self.settings.sync()
        self._populate_recent_files()

    def _populate_recent_files(self):
        self.recent_file_list.clear()
        for f in self.recent_files:
            if os.path.exists(f) and f.lower().endswith(".hip"):
                self.recent_file_list.addItem(f)

    def _recent_file_double_clicked(self, item):
        full_path = item.text()
        if os.path.exists(full_path):
            ext = os.path.splitext(full_path)[1].lower()
            name_no_ext = os.path.splitext(os.path.basename(full_path))[0]
            safe_name = self._sanitize_node_name(name_no_ext)
            try:
                if ext == ".hip":
                    hou.hipFile.load(full_path.replace('\\', '/'))
                elif ext == ".abc":
                    obj = hou.node("/obj")
                    geo_node = obj.createNode("geo", node_name=safe_name, run_init_scripts=False, force_valid_node_name=True)
                    alembic_node = geo_node.createNode("alembic", node_name=safe_name)
                    alembic_node.parm("fileName").set(full_path.replace('\\', '/'))
                    geo_node.layoutChildren()
                else:
                    obj = hou.node("/obj")
                    geo_node = obj.createNode("geo", node_name=safe_name, run_init_scripts=False, force_valid_node_name=True)
                    file_node = geo_node.createNode("file", node_name="file1")
                    file_node.parm("file").set(full_path.replace('\\', '/'))
                    geo_node.layoutChildren()

                self.browser_path_display.setText(os.path.dirname(full_path))
                self._browser_populate_files(os.path.dirname(full_path))
                self._add_to_recent(full_path)

            except Exception as e:
                print(f"Error opening recent file: {e}")
                try:
                    hou.ui.displayMessage(f"Error opening file:\n{e}")
                except:
                    pass
        else:
            QMessageBox.warning(self, "File Not Found", "The recent file no longer exists.")
            if full_path in self.recent_files:
                self.recent_files.remove(full_path)
                self.settings.setValue("browser/recent_files", self.recent_files)
                self.settings.sync()
            self._populate_recent_files()

def show_browser_tool():
    try:
        if hasattr(hou.session, "browser_tool_ui"):
            old_win = hou.session.browser_tool_ui
            if old_win is not None:
                if old_win.isVisible():
                    old_win.raise_()
                    old_win.activateWindow()
                    return
                else:
                    hou.session.browser_tool_ui = None

        main_window = hou.ui.mainQtWindow()
        tool = BrowserTool()

        DARK_STYLE = """
        QWidget {
            background-color: #1e1e1e;
            color: #FFFFFF;
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            font-size: 12px;
        }
        QLineEdit, QComboBox, QListWidget, QTreeWidget {
            background-color: #2c2c2c;
            border: none;
            border-radius: 4px;
            outline: none;
        }
        QLineEdit:focus, QComboBox:focus, QListWidget:focus, QTreeWidget:focus {
            border: 1px solid #00aaff;
        }
        QPushButton {
            background-color: #bfbfbf;
            color: #1e1e1e;
            padding: 1px 1px;
            border-radius: 4px;
            font-weight: 400;
            min-width: 40px;
        }
        QPushButton:hover { background-color: #555555; }
        QPushButton:pressed { background-color: #222222; }
        QListWidget::item:selected, QTreeWidget::item:selected {
            background-color: #005f87;
            color: #ffffff;
        }
        QScrollBar:vertical {
            background: #2b2b2b;
            width: 12px;
        }
        QScrollBar::handle:vertical {
            background: #555555;
            min-height: 20px;
            border-radius: 4px;
        }
        QScrollBar::handle:vertical:hover { background: #888888; }
        """

        win = QtWidgets.QMainWindow(parent=main_window)
        win.setWindowTitle("Houdini Browser Tool")
        win.setMinimumSize(900, 550)
        win.setStyleSheet(DARK_STYLE)
        win.setWindowFlags(
            QtCore.Qt.Window |
            QtCore.Qt.WindowMinimizeButtonHint |
            QtCore.Qt.WindowMaximizeButtonHint |
            QtCore.Qt.WindowCloseButtonHint
        )

        central_widget = QtWidgets.QWidget()
        stacked_layout = QtWidgets.QStackedLayout()
        central_widget.setLayout(stacked_layout)
        win.setCentralWidget(central_widget)

        main_page = tool.create_browser_page()
        stacked_layout.addWidget(main_page)

        save_btn = QtWidgets.QPushButton("ð¾ ")
        save_btn.setParent(central_widget)
        save_btn.setToolTip("Save Hip File")
        save_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #1e1e1e;
                font-weight: bold;
                border-radius: 10px;
                padding: 0px;
                border: 0px solid rgba(255, 255, 255, 0);
            }
            QPushButton:hover { background-color: rgba(76, 175, 80, 0.0); color: rgba(76, 175, 80, 0.9);}
        """)
        save_btn.resize(40, 40)
        save_btn.clicked.connect(tool._save_versioned_hip)

        def reposition_button():
            parent_size = central_widget.size()
            btn_width, btn_height = save_btn.size().width(), save_btn.size().height()
            save_btn.move(parent_size.width() - btn_width - 20, parent_size.height() - btn_height - 20)

        central_widget.resizeEvent = lambda event: reposition_button()

        win.show()
        hou.session.browser_tool_ui = win

    except Exception as e:
        print("Failed to open browser tool:", e)

# Run it
show_browser_tool()
]]></script>
  </tool>

  <tool name="deadline" label="DeadlineManager" icon="$XLAB/icons/deadline.png">
    <script scriptType="python"><![CDATA[import os
import re
import platform
import getpass
import subprocess
from PySide2 import QtWidgets, QtCore
from PySide2.QtCore import QDate, QDateTime
from PySide2.QtWidgets import QLabel


# ---------------------------
# Worker threads
# ---------------------------
class DeadlineJobLoader(QtCore.QThread):
    jobs_loaded = QtCore.Signal(list)  # list of job dicts
    error = QtCore.Signal(str)

    def __init__(self, deadline_cmd, user=None, parent=None):
        super().__init__(parent)
        self.deadline_cmd = deadline_cmd
        self.user = user

    def run(self):
        jobs = []
        try:
            args = [self.deadline_cmd, "GetJobs"]
            if self.user:
                args += ["-UserName", self.user]
            result = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            out = result.stdout.strip() or result.stderr.strip()
            current_job = {}
            for line in out.splitlines():
                if "=" in line:
                    k, v = line.split("=", 1)
                    current_job[k.strip()] = v.strip()
                elif not line.strip():  # blank line => job boundary
                    if current_job:
                        jobs.append(current_job.copy())
                        current_job.clear()
            if current_job:
                jobs.append(current_job.copy())
        except Exception as e:
            self.error.emit(str(e))
        finally:
            self.jobs_loaded.emit(jobs)


class JobInfoLoader(QtCore.QThread):
    info_loaded = QtCore.Signal(dict)
    error = QtCore.Signal(str)

    def __init__(self, deadline_cmd, job_id, parent=None):
        super().__init__(parent)
        self.deadline_cmd = deadline_cmd
        self.job_id = job_id

    def run(self):
        parsed = {}
        try:
            result = subprocess.run([self.deadline_cmd, "GetJob", self.job_id], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            out = result.stdout.strip() or result.stderr.strip()
            for line in out.splitlines():
                if "=" in line:
                    k, v = line.split("=", 1)
                    parsed[k.strip()] = v.strip()
        except Exception as e:
            self.error.emit(str(e))
        finally:
            self.info_loaded.emit(parsed)


class CommandRunner(QtCore.QThread):
    finished_running = QtCore.Signal(str, bool, str)  # command, success, message

    def __init__(self, deadline_cmd, command, job_id, parent=None):
        super().__init__(parent)
        self.deadline_cmd = deadline_cmd
        self.command = command
        self.job_id = job_id

    def run(self):
        try:
            result = subprocess.run([self.deadline_cmd, self.command, self.job_id], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            success = result.returncode == 0
            msg = (result.stdout.strip() or result.stderr.strip())
            self.finished_running.emit(self.command, success, msg)
        except Exception as e:
            self.finished_running.emit(self.command, False, str(e))

# ---------------------------
# Main GUI
# ---------------------------
class DeadlineGUI(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Deadline Jobs Viewer")
        self.resize(900, 550)
        self.apply_dark_theme()
        self.jobs = []
        self.threads = []  # keep references to threads to avoid GC
        layout = QtWidgets.QVBoxLayout(self)
        layout.addWidget(self.create_deadline_page())

    def closeEvent(self, event):
        """Reset global instance on close so it can be reopened."""
        app = QtWidgets.QApplication.instance()
        if hasattr(app, "_deadline_viewer_instance"):
            app._deadline_viewer_instance = None
        super().closeEvent(event)
        
    def create_deadline_page(self):
        left = QtWidgets.QWidget()
        left_layout = QtWidgets.QVBoxLayout(left)

        # Filters
        filter_layout = QtWidgets.QHBoxLayout()
        self.search_bar = QtWidgets.QLineEdit()
        self.search_bar.setPlaceholderText("ð Search jobs (name/user/id)...")
        self.search_bar.textChanged.connect(self.apply_deadline_filter)
        filter_layout.addWidget(self.search_bar)

        self.user_filter = QtWidgets.QComboBox()
        self.user_filter.setEditable(True)
        self.user_filter.setMinimumWidth(140)
        self.user_filter.addItem(getpass.getuser())
        self.user_filter.setCurrentText(getpass.getuser())
        self.user_filter.currentIndexChanged.connect(self.apply_deadline_filter)
        filter_layout.addWidget(QLabel("User:"))
        filter_layout.addWidget(self.user_filter)

        self.date_start = QtWidgets.QDateEdit(calendarPopup=True)
        self.date_end = QtWidgets.QDateEdit(calendarPopup=True)
        self.date_start.setDate(QDate.currentDate().addDays(-7))
        self.date_end.setDate(QDate.currentDate())
        self.date_start.dateChanged.connect(self.apply_deadline_filter)
        self.date_end.dateChanged.connect(self.apply_deadline_filter)
        filter_layout.addWidget(QLabel("From:"))
        filter_layout.addWidget(self.date_start)
        filter_layout.addWidget(QLabel("To:"))
        filter_layout.addWidget(self.date_end)

        self.auto_refresh_chk = QtWidgets.QCheckBox("Auto-refresh")
        self.auto_refresh_chk.setToolTip("Automatically refresh deadline jobs every interval")
        self.auto_refresh_chk.stateChanged.connect(self._toggle_deadline_autorefresh)
        filter_layout.addWidget(self.auto_refresh_chk)

        self.auto_interval = QtWidgets.QSpinBox()
        self.auto_interval.setMinimum(5)
        self.auto_interval.setMaximum(3600)
        self.auto_interval.setValue(20)
        self.auto_interval.setSuffix(" s")
        self.auto_interval.setToolTip("Auto-refresh interval (seconds)")
        filter_layout.addWidget(self.auto_interval)

        self.refresh_btn = QtWidgets.QPushButton("ð Refresh")
        self.refresh_btn.clicked.connect(self.load_deadline_jobs)
        filter_layout.addWidget(self.refresh_btn)

        left_layout.addLayout(filter_layout)

        # Job table
        self.deadline_table = QtWidgets.QTableWidget()
        self.deadline_table.setColumnCount(14)
        self.deadline_table.setHorizontalHeaderLabels([
            "Job Name", "User", "Progress", "Status", "Frames", "Pool",
            "Priority", "Submitted", "Started", "Completed",
            "Output Directory", "Output File", "Submitted From", "Job ID"
        ])
        self.deadline_table.setSortingEnabled(True)
        self.deadline_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.deadline_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.deadline_table.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.deadline_table.customContextMenuRequested.connect(self.show_deadline_context_menu)
        self.deadline_table.itemSelectionChanged.connect(self._deadline_row_selected)
        self.deadline_table.itemDoubleClicked.connect(self._deadline_row_selected)
        left_layout.addWidget(self.deadline_table)

        # Action buttons
        actions_row = QtWidgets.QHBoxLayout()
        self.suspend_btn = QtWidgets.QPushButton("ð Suspend")
        self.resume_btn = QtWidgets.QPushButton("â¶ï¸ Resume")
        self.delete_btn = QtWidgets.QPushButton("â Delete")
        self.suspend_btn.clicked.connect(self.suspend_selected_jobs)
        self.resume_btn.clicked.connect(self.resume_selected_jobs)
        self.delete_btn.clicked.connect(self.delete_selected_jobs)
        actions_row.addWidget(self.suspend_btn)
        actions_row.addWidget(self.resume_btn)
        actions_row.addWidget(self.delete_btn)
        actions_row.addStretch()
        left_layout.addLayout(actions_row)

        main = QtWidgets.QHBoxLayout()
        main.addWidget(left)


        page = QtWidgets.QWidget()
        page.setLayout(main)

        self._deadline_timer = QtCore.QTimer(self)
        self._deadline_timer.timeout.connect(self.load_deadline_jobs)

        return page

    def apply_dark_theme(self):
        modern_stylesheet = """
        QWidget {
            background-color: #2b2b2b;
            color: #dddddd;
            font-family: "Segoe UI", "Arial", sans-serif;
            font-size: 8pt;
        }
        QLineEdit, QComboBox, QListWidget {
        background-color: #2c2c2c;  /* Slightly lighter dark grey for list */
        border: none;
        border-radius: 4px;
        outline: none;
        }
        QLineEdit:focus, QComboBox:focus, QListWidget:focus {
            border: 1px solid #00aaff;
        }
        QPushButton {
        background-color: #bfbfbf;  /* Light gray button bg */
        color: #1e1e1e;             /* Dark text on button */
        padding: 2px 2px;          /* Smaller padding */
        border-radius: 4px;         /* Rounded corners with 4px radius */
        font-weight: 400;
        min-width: 80px;            /* Reduced minimum width */
        transition: background-color 0.2s ease, color 0.2s ease;
        }
        QPushButton:hover {
            background-color: #555555;
        }
        QPushButton:pressed {
            background-color: #222222;
        }
        QListWidget::item:selected {
            background-color: #005f87;
            color: #ffffff;
        }
        QScrollBar:vertical {
            background: #2b2b2b;
            width: 12px;
        }
        QScrollBar::handle:vertical {
            background: #555555;
            min-height: 20px;
            border-radius: 4px;
        }
        QScrollBar::handle:vertical:hover {
            background: #888888;
        }
        """
        self.setStyleSheet(modern_stylesheet)

        
    def _toggle_deadline_autorefresh(self, state):
        if state == QtCore.Qt.Checked:
            interval_sec = max(5, int(self.auto_interval.value()))
            self._deadline_timer.start(interval_sec * 1000)
        else:
            self._deadline_timer.stop()

    # ---------------------------
    # Loading jobs (threaded)
    # ---------------------------
    def load_deadline_jobs(self):
        # Avoid overlapping refreshes
        self._deadline_timer.stop()
        self.saved_filter_text = self.search_bar.text()
        self.search_bar.blockSignals(True)
        self.search_bar.clear()
        self.deadline_table.setRowCount(0)
        self.jobs = []

        deadline_bin_dir = os.getenv("DEADLINE_PATH", r"C:\Program Files\Thinkbox\Deadline10\bin")
        self.deadline_cmd = os.path.join(deadline_bin_dir, "deadlinecommand")
        if platform.system() == "Windows" and not self.deadline_cmd.lower().endswith(".exe"):
            if os.path.isfile(self.deadline_cmd + ".exe"):
                self.deadline_cmd += ".exe"

        user = self.user_filter.currentText().strip() or getpass.getuser()

        # disable refresh while loading
        self.refresh_btn.setEnabled(False)

        loader = DeadlineJobLoader(self.deadline_cmd, user)
        loader.jobs_loaded.connect(self._jobs_from_thread)
        loader.error.connect(self._worker_error)
        loader.finished.connect(lambda: self._thread_cleanup(loader))
        loader.start()
        self.threads.append(loader)

    def _thread_cleanup(self, thread):
        # keep list small, and delete finished refs
        try:
            self.threads = [t for t in self.threads if t.isRunning()]
        except Exception:
            self.threads = []

    def _worker_error(self, msg):
        # show minimal message (main thread)
        print("Worker error:", msg)

    def _jobs_from_thread(self, jobs):
        # Called on main thread via signal
        unique = {}
        for job in jobs:
            jobid = job.get("JobId") or job.get("Id") or job.get("ID") or ""
            if jobid not in unique:
                job["__parsed_jobid"] = jobid
                job["__submit_qdate"] = self._parse_job_submit_date(
                    job.get("JobSubmitDateTime", "") or job.get("JobSubmitDate", "")
                )
                unique[jobid] = job
    
        # replace jobs with unique set
        self.jobs = list(unique.values())
    
        # restore search text and enable refresh
        self.search_bar.blockSignals(False)
        try:
            self.search_bar.setText(self.saved_filter_text)
        finally:
            self.refresh_btn.setEnabled(True)
    
        self.apply_deadline_filter()
    
        # restart auto timer if needed
        if self.auto_refresh_chk.isChecked():
            self._deadline_timer.start(self.auto_interval.value() * 1000)


    def _parse_job_submit_date(self, val):
        if not val:
            return None
        try:
            if str(val).isdigit():
                dt = QDateTime.fromSecsSinceEpoch(int(val))
                return dt.date()
            for fmt in ("yyyy-MM-dd hh:mm:ss", "yyyy-MM-ddThh:mm:ss", "yyyy-MM-dd hh:mm", "yyyy-MM-dd"):
                dt = QDateTime.fromString(val, fmt)
                if dt.isValid():
                    return dt.date()
            m = re.search(r"(\d{4}-\d{2}-\d{2})", val)
            if m:
                dt = QDateTime.fromString(m.group(1), "yyyy-MM-dd")
                if dt.isValid():
                    return dt.date()
        except Exception:
            pass
        return None

    # ---------------------------
    # Table population (main thread only)
    # ---------------------------
    def add_deadline_job_row(self, job):
        row = self.deadline_table.rowCount()
        self.deadline_table.insertRow(row)

        name = job.get("Name", "Unknown")
        user = job.get("UserName", "") or job.get("User", "")
        status = job.get("Status", "")
        pool = job.get("Pool", "")
        priority = str(job.get("Priority", ""))
        job_id = job.get("__parsed_jobid", "UNKNOWN")
        raw_frames = job.get("Frames", "")
        frame_numbers = set()

        if isinstance(raw_frames, str):
            parts = re.split(r"[,\s]+", raw_frames.strip())
            for p in parts:
                if "-" in p:
                    try:
                        a, b = p.split("-", 1)
                        frame_numbers.update(range(int(a), int(b) + 1))
                    except:
                        pass
                elif p.isdigit():
                    frame_numbers.add(int(p))

        frame_list = sorted(frame_numbers)
        frame_range = f"{frame_list[0]}-{frame_list[-1]}" if frame_list else ""

        submit_time = job.get("JobSubmitDateTime", "")
        started_time = job.get("JobStartedDateTime", "")
        completed_time = job.get("JobCompletedDateTime", "")
        output_dir = job.get("JobOutputDirectories", "")
        output_file = job.get("JobOutputFileNames", "")
        output_dir = output_dir[0] if isinstance(output_dir, list) and output_dir else output_dir
        output_file = output_file[0] if isinstance(output_file, list) and output_file else output_file
        submit_machine = job.get("JobSubmitMachine", "")

        try:
            completed = int(job.get("JobCompletedTasks", 0))
            total = int(job.get("JobTaskCount", 1))
            progress = int((completed / total) * 100) if total > 0 else 0
        except:
            progress = 0

        columns = [
            name, user, None, status, frame_range, pool,
            priority, submit_time, started_time, completed_time,
            output_dir, output_file, submit_machine, job_id
        ]

        for i, value in enumerate(columns):
            if i == 2:
                pb = QtWidgets.QProgressBar()
                pb.setValue(progress)
                pb.setAlignment(QtCore.Qt.AlignCenter)
                pb.setFormat(f"{progress}%")
                pb.setFixedHeight(16)
                self.deadline_table.setCellWidget(row, i, pb)
            else:
                item = QtWidgets.QTableWidgetItem(value or "")
                item.setTextAlignment(QtCore.Qt.AlignCenter)
                item.setData(QtCore.Qt.UserRole, job_id)
                self.deadline_table.setItem(row, i, item)

    def apply_deadline_filter(self):
        filter_text = self.search_bar.text().lower().strip()
        user_filter_text = (self.user_filter.currentText() or "").lower().strip()
        date_from = self.date_start.date()
        date_to = self.date_end.date()

        self.deadline_table.setRowCount(0)
        for job in getattr(self, "jobs", []):
            name = job.get("Name", "").lower()
            user = (job.get("UserName", "") or job.get("User", "")).lower()
            jobid = (job.get("__parsed_jobid", "") or "").lower()
            submit_qdate = job.get("__submit_qdate", None)
            if not submit_qdate:
                continue
            if not (date_from <= submit_qdate <= date_to):
                continue
            if user_filter_text and user_filter_text not in user:
                continue
            if filter_text and filter_text not in name and filter_text not in user and filter_text not in jobid:
                continue
            self.add_deadline_job_row(job)

    def get_selected_job_ids(self):
        selected = self.deadline_table.selectionModel().selectedRows()
        job_ids = set()
        for row in selected:
            for col in range(self.deadline_table.columnCount()):
                item = self.deadline_table.item(row.row(), col)
                if item and item.data(QtCore.Qt.UserRole):
                    job_ids.add(item.data(QtCore.Qt.UserRole))
                    break
        return list(job_ids)

    def show_deadline_context_menu(self, pos):
        index = self.deadline_table.indexAt(pos)
        if not index.isValid():
            return
        self.deadline_table.selectRow(index.row())
        job_id = self.deadline_table.item(index.row(), 0).data(QtCore.Qt.UserRole)
        if not job_id:
            return
    
        menu = QtWidgets.QMenu(self)
    
        # Apply flat, semi-transparent, modern style
        menu.setWindowFlags(menu.windowFlags() | QtCore.Qt.FramelessWindowHint | QtCore.Qt.NoDropShadowWindowHint)
        menu.setAttribute(QtCore.Qt.WA_TranslucentBackground, True)
        menu.setStyleSheet("""
            QMenu {
                background-color: rgba(40, 40, 40, 180);
                border-radius: 6px;
                padding: 2px;
                color: #ffffff;
            }
            QMenu::item {
                padding: 2px 20px;
                border-radius: 6px;
                background-color: transparent;
            }
            QMenu::item:selected {
                background-color: rgba(255, 255, 255, 50);
                color: #ffffff;
            }
        """)
    
        menu.addAction("ð Suspend", self.suspend_selected_jobs)
        menu.addAction("â¶ï¸ Resume", self.resume_selected_jobs)
        menu.addAction("â Delete", self.delete_selected_jobs)
        menu.addSeparator()
        menu.addAction("ð View Job Info", lambda jid=job_id: self.fetch_and_show_job_info(jid))
    
        menu.exec_(self.deadline_table.viewport().mapToGlobal(pos))


    def _deadline_row_selected(self):
        sels = self.deadline_table.selectionModel().selectedRows()
        if not sels:
            return
        row = sels[0].row()
        job_id = self.deadline_table.item(row, 0).data(QtCore.Qt.UserRole)
        if job_id:
            self.fetch_and_show_job_info(job_id)


    # ---------------------------
    # Job info (threaded)
    # ---------------------------
    def fetch_and_show_job_info(self, job_id):
        # ensure self.deadline_cmd exists
        if not hasattr(self, "deadline_cmd") or not self.deadline_cmd:
            deadline_bin_dir = os.getenv("DEADLINE_PATH", r"C:\Program Files\Thinkbox\Deadline10\bin")
            self.deadline_cmd = os.path.join(deadline_bin_dir, "deadlinecommand")
            if platform.system() == "Windows" and os.path.isfile(self.deadline_cmd + ".exe"):
                self.deadline_cmd += ".exe"

        info_loader = JobInfoLoader(self.deadline_cmd, job_id)
        info_loader.info_loaded.connect(self._show_job_info)
        info_loader.error.connect(self._worker_error)
        info_loader.finished.connect(lambda: self._thread_cleanup(info_loader))
        info_loader.start()
        self.threads.append(info_loader)

    def _show_job_info(self, parsed):
        # Create a modal dialog to show job info
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Job Info")
        dialog.resize(600, 400)
        layout = QtWidgets.QVBoxLayout(dialog)
    
        table = QtWidgets.QTableWidget()
        table.setColumnCount(2)
        table.setHorizontalHeaderLabels(["Field", "Value"])
        table.horizontalHeader().setStretchLastSection(True)
        table.verticalHeader().setVisible(False)
    
        for i, (k, v) in enumerate(sorted(parsed.items())):
            table.insertRow(i)
            table.setItem(i, 0, QtWidgets.QTableWidgetItem(k))
            table.setItem(i, 1, QtWidgets.QTableWidgetItem(v))
    
        layout.addWidget(table)
    
        btn_close = QtWidgets.QPushButton("Close")
        btn_close.clicked.connect(dialog.accept)
        layout.addWidget(btn_close)
    
        dialog.exec_()


    # ---------------------------
    # Run commands (threaded)
    # ---------------------------
    def _run_command_on_jobs(self, command, job_ids):
        if not job_ids:
            return
        if not hasattr(self, "deadline_cmd") or not self.deadline_cmd:
            deadline_bin_dir = os.getenv("DEADLINE_PATH", r"C:\Program Files\Thinkbox\Deadline10\bin")
            self.deadline_cmd = os.path.join(deadline_bin_dir, "deadlinecommand")
            if platform.system() == "Windows" and os.path.isfile(self.deadline_cmd + ".exe"):
                self.deadline_cmd += ".exe"

        # optionally disable action buttons to prevent double-clicks
        self.suspend_btn.setEnabled(False)
        self.resume_btn.setEnabled(False)
        self.delete_btn.setEnabled(False)

        for jid in job_ids:
            runner = CommandRunner(self.deadline_cmd, command, jid)
            runner.finished_running.connect(self._command_finished)
            runner.finished.connect(lambda: self._thread_cleanup(runner))
            runner.start()
            self.threads.append(runner)

    def suspend_selected_jobs(self):
        self._run_command_on_jobs("SuspendJob", self.get_selected_job_ids())
        # refresh after a short delay
        QtCore.QTimer.singleShot(400, self.load_deadline_jobs)

    def resume_selected_jobs(self):
        self._run_command_on_jobs("ResumeJob", self.get_selected_job_ids())
        QtCore.QTimer.singleShot(400, self.load_deadline_jobs)

    def delete_selected_jobs(self):
        self._run_command_on_jobs("DeleteJob", self.get_selected_job_ids())
        QtCore.QTimer.singleShot(400, self.load_deadline_jobs)

    def _command_finished(self, command, success, message):
        # Called on main thread
        print(f"{command} finished: success={success}, msg={message}")
        # re-enable action buttons (could be more nuanced)
        self.suspend_btn.setEnabled(True)
        self.resume_btn.setEnabled(True)
        self.delete_btn.setEnabled(True)
        # optionally show small popup for failures
        if not success:
            QtWidgets.QMessageBox.warning(self, f"{command} failed", message or "Unknown error")



def show_deadline_viewer():
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])
    
    if not hasattr(app, "_deadline_viewer_instance") or app._deadline_viewer_instance is None:
        viewer = DeadlineGUI()
        viewer.show()
        viewer.load_deadline_jobs()
        app._deadline_viewer_instance = viewer
    else:
        viewer = app._deadline_viewer_instance
        viewer.raise_()
        viewer.activateWindow()
    
    return viewer

# Always launch (but only once at a time)
show_deadline_viewer()

]]></script>
  </tool>

  <tool name="viewportFlipbook" label="ViewportFlipbook" icon="$XLAB/icons/ViewportFlipbook.png">
    <script scriptType="python"><![CDATA[import hou
import os
import re
import sys
import subprocess
import toolutils
from PySide2 import QtWidgets, QtCore


# --------- Utilities --------- #

def get_ffmpeg_bin():
    XLAB = os.getenv("XLAB")
    if not XLAB:
        raise hou.Error("XLAB environment variable not set.")
    ffmpeg = os.path.join(XLAB, "ffmpeg", "bin", "ffmpeg.exe" if os.name == "nt" else "ffmpeg")
    if not os.path.exists(ffmpeg):
        raise hou.Error(f"FFmpeg not found:\n{ffmpeg}")
    return ffmpeg


def find_next_version(base_folder):
    if not os.path.exists(base_folder):
        return "V001"
    versions = [v for v in os.listdir(base_folder) if re.match(r"V\d{3}", v)]
    if not versions:
        return "V001"
    versions.sort()
    last = versions[-1]
    next_num = int(last[1:]) + 1
    return f"V{next_num:03}"


# --------- Dialog --------- #

class FlipbookDialog(QtWidgets.QDialog):
    def __init__(self, start="1001", end="1100", version="V001", parent=None):
        super(FlipbookDialog, self).__init__(parent)
        self.setWindowTitle("Viewport Flipbook Settings")
        self.setFixedWidth(300)

        layout = QtWidgets.QFormLayout(self)

        self.start_edit = QtWidgets.QLineEdit(start)
        self.end_edit = QtWidgets.QLineEdit(end)
        self.version_edit = QtWidgets.QLineEdit(version)
        self.open_checkbox = QtWidgets.QCheckBox("Open MP4 After Render")
        self.open_checkbox.setChecked(False)

        layout.addRow("Start Frame:", self.start_edit)
        layout.addRow("End Frame:", self.end_edit)
        layout.addRow("Version:", self.version_edit)
        layout.addRow("", self.open_checkbox)

        btn_layout = QtWidgets.QHBoxLayout()
        self.ok_btn = QtWidgets.QPushButton("Flipbook")
        self.cancel_btn = QtWidgets.QPushButton("Cancel")
        btn_layout.addWidget(self.ok_btn)
        btn_layout.addWidget(self.cancel_btn)
        layout.addRow(btn_layout)

        self.ok_btn.clicked.connect(self.validate_and_accept)
        self.cancel_btn.clicked.connect(self.reject)

    def validate_and_accept(self):
        if not (self.start_edit.text().isdigit() and self.end_edit.text().isdigit()):
            QtWidgets.QMessageBox.warning(self, "Invalid Input", "Start and End must be integers.")
            return
        if not self.version_edit.text().strip():
            QtWidgets.QMessageBox.warning(self, "Invalid Input", "Version cannot be empty.")
            return
        self.accept()

    def get_values(self):
        return (
            int(self.start_edit.text()),
            int(self.end_edit.text()),
            self.version_edit.text().strip(),
            self.open_checkbox.isChecked()
        )


# --------- Main --------- #

def main():
    # Prepare context
    hipfile = hou.hipFile.path()
    if not hipfile:
        raise hou.Error("Please save your scene before flipbooking.")
    hip_name = os.path.splitext(os.path.basename(hipfile))[0]
    hip_dir = os.path.dirname(hipfile)
    flipbook_dir = os.path.join(hip_dir, "Flipbooks")
    version_guess = find_next_version(flipbook_dir)

    start, end = hou.playbar.frameRange()
    default_start = str(int(start))
    default_end = str(int(end))

    # Create dialog
    app = QtWidgets.QApplication.instance()
    if not app:
        app = QtWidgets.QApplication([])  # Only needed outside Houdini

    dialog = FlipbookDialog(start=default_start, end=default_end, version=version_guess)
    if not dialog.exec_():
        return  # Cancelled

    start_frame, end_frame, version_str, open_after = dialog.get_values()

    # Scene Viewer & Camera
    viewer = toolutils.sceneViewer()
    viewport = viewer.curViewport()
    camera = viewport.camera()
    if not camera:
        raise hou.Error("Please lock a camera to the viewport.")

    resx = int(camera.parm("resx").eval())
    resy = int(camera.parm("resy").eval())

    # Setup output
    version_folder = os.path.join(flipbook_dir, version_str)
    os.makedirs(version_folder, exist_ok=True)
    image_pattern = os.path.join(version_folder, f"{hip_name}_{version_str}.$F4.exr")

    # Flipbook settings
    settings = viewer.flipbookSettings()
    settings.stash()
    settings.output(image_pattern)
    settings.frameRange((start_frame, end_frame))
    settings.useResolution(True)
    settings.resolution((resx, resy))

    settings.useMotionBlur(False)
    settings.cropOutMaskOverlay(True)

    viewer.flipbook(viewport, settings)

    # MP4 render via ffmpeg
    try:
        ffmpeg = get_ffmpeg_bin()

        mp4_dir = os.path.normpath(os.path.join(flipbook_dir, "mp4"))
        os.makedirs(mp4_dir, exist_ok=True)

        exr_seq = os.path.normpath(os.path.join(version_folder, f"{hip_name}_{version_str}.%04d.exr"))
        mp4_path = os.path.normpath(os.path.join(mp4_dir, f"{hip_name}.{version_str}.mp4"))

        cmd = [
            ffmpeg,
            "-y",
            "-start_number", str(start_frame),
            "-framerate", "24",
            "-i", exr_seq,
            "-c:v", "libx264",
            "-preset", "veryslow",
            "-crf", "0",  # Lossless CRF
            "-pix_fmt", "yuv444p",  # Full chroma (optional, if source supports it)
            mp4_path
        ]

        result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if result.returncode != 0:
            raise hou.Error("FFmpeg failed:\n" + result.stderr.decode())

        if open_after:
            if sys.platform == "win32":
                os.startfile(mp4_path)
            elif sys.platform == "darwin":
                subprocess.call(["open", mp4_path])
            else:
                subprocess.call(["xdg-open", mp4_path])

    except Exception as e:
        hou.ui.displayMessage(f"Flipbook succeeded, but MP4 creation failed:\n{e}")


main()
]]></script>
  </tool>

  <tool name="openGlFlipbook" label="OpenGlFlipbook" icon="$XLAB/icons/OpenGLFlipbook.png">
    <script scriptType="python"><![CDATA[import hou
import os
import re
import subprocess
import sys
from PySide2 import QtWidgets, QtCore

def get_ffmpeg_bin():
    XLAB = os.getenv("XLAB")
    if not XLAB:
        raise hou.Error("Environment variable XLAB is not set.")
    ffmpeg = os.path.join(XLAB, "ffmpeg", "bin", "ffmpeg.exe")
    if not os.path.exists(ffmpeg):
        raise hou.Error(f"ffmpeg.exe not found at:\n{ffmpeg}")
    return ffmpeg

def find_next_version(base_folder):
    if not os.path.exists(base_folder):
        return "V001"
    versions = [entry for entry in os.listdir(base_folder)
                if os.path.isdir(os.path.join(base_folder, entry)) and re.match(r"V\d{3}", entry)]
    if not versions:
        return "V001"
    versions.sort()
    last_version = versions[-1]
    next_version_number = int(last_version[1:]) + 1
    return f"V{next_version_number:03}"

class FlipbookDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, start="1001", end="1100", version="V001"):
        super().__init__(parent)
        self.setWindowTitle("Flipbook Parameters")
        self.setFixedWidth(300)

        form_layout = QtWidgets.QFormLayout(self)

        self.start_edit = QtWidgets.QLineEdit(start)
        self.end_edit = QtWidgets.QLineEdit(end)
        self.version_edit = QtWidgets.QLineEdit(version)
        self.open_checkbox = QtWidgets.QCheckBox("Open MP4 after render")
        self.open_checkbox.setChecked(False)  # Default to OFF

        form_layout.addRow("Start Frame:", self.start_edit)
        form_layout.addRow("End Frame:", self.end_edit)
        form_layout.addRow("Version:", self.version_edit)
        form_layout.addRow("", self.open_checkbox)

        button_layout = QtWidgets.QHBoxLayout()
        self.flipbook_button = QtWidgets.QPushButton("Flipbook")
        self.cancel_button = QtWidgets.QPushButton("Cancel")
        button_layout.addWidget(self.flipbook_button)
        button_layout.addWidget(self.cancel_button)

        form_layout.addRow(button_layout)

        self.flipbook_button.clicked.connect(self.validate_and_accept)
        self.cancel_button.clicked.connect(self.reject)

    def validate_and_accept(self):
        if not self.start_edit.text().isdigit() or not self.end_edit.text().isdigit():
            QtWidgets.QMessageBox.warning(self, "Invalid Input", "Start and End frames must be integers.")
            return
        if not self.version_edit.text().strip():
            QtWidgets.QMessageBox.warning(self, "Invalid Input", "Version cannot be empty.")
            return
        self.accept()

    def get_values(self):
        return (
            self.start_edit.text(),
            self.end_edit.text(),
            self.version_edit.text().strip(),
            self.open_checkbox.isChecked()
        )

def open_sequence_in_mplay(first_frame_path, total_frames):
    match = re.match(r"(.*?)(\d+)\.exr$", os.path.basename(first_frame_path))
    if not match:
        hou.ui.displayMessage("Invalid EXR filename format.")
        return

    prefix, frame_str = match.groups()
    start_frame = int(frame_str)
    end_frame = start_frame + total_frames - 1
    padding = len(frame_str)

    sequence_pattern = f"{prefix}$F{padding}.exr"
    directory = os.path.dirname(first_frame_path)
    full_pattern = os.path.join(directory, sequence_pattern)

    mplay_path = os.path.join(hou.getenv("HFS"), "bin", "mplay")

    try:
        # Pass start, end, and step ('1') as separate arguments after '-f'
        subprocess.Popen([mplay_path, "-f", str(start_frame), str(end_frame), "1", full_pattern])
    except Exception as e:
        hou.ui.displayMessage(f"Could not launch MPlay:\n{str(e)}")


def main():
    ffmpeg_bin = get_ffmpeg_bin()

    hipfile = hou.hipFile.path()
    hip = os.path.dirname(hipfile)
    hip_name = os.path.splitext(os.path.basename(hipfile))[0]

    base = os.path.join(hip, "Flipbooks")
    version_guess = find_next_version(base)

    start, end = hou.playbar.frameRange()
    default_start = str(int(start))
    default_end = str(int(end))

    app = QtWidgets.QApplication.instance()
    if not app:
        app = QtWidgets.QApplication([])

    dialog = FlipbookDialog(start=default_start, end=default_end, version=version_guess)
    if dialog.exec_() != QtWidgets.QDialog.Accepted:
        return  # silently exit if user cancels

    start_f_str, end_f_str, user_version, open_after = dialog.get_values()
    start_f = int(start_f_str)
    end_f = int(end_f_str)

    exr_folder = os.path.join(base, user_version)
    os.makedirs(exr_folder, exist_ok=True)

    viewer = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer)
    if not viewer:
        raise hou.Error("No Scene Viewer found.")
    viewport = viewer.curViewport()
    camera = viewport.camera()
    if not camera:
        raise hou.Error("Lock a camera to the viewport before running the script.")

    resx = int(camera.parm("resx").eval())
    resy = int(camera.parm("resy").eval())

    # Create temporary OpenGL ROP
    rop = hou.node("/out").createNode("opengl", node_name="temp_flipbook")
    exr_pattern = os.path.join(exr_folder, f"{hip_name}_{user_version}.$F4.exr")
    rop.setParms({
        "camera": camera.path(),
        "trange": 1,
        "f1": start_f,
        "f2": end_f,
        "f3": 1,
        "res1": resx,
        "res2": resy,
        "tres": True,
        "picture": exr_pattern,
        "alights": "",
        "aamode": 6,  # High quality AA
        "usehdr": 2   # HDR setting
    })

    if camera.parm("vm_background"):
        bg_image = camera.parm("vm_background").unexpandedString()
        if bg_image:
            rop.parm("bgimage").set(bg_image)
    if rop.parm("soho_initsim"):
        rop.parm("soho_initsim").set(True)

    rop.parm("execute").pressButton()
    rop.destroy()

    mp4_dir = os.path.join(base, "mp4")
    os.makedirs(mp4_dir, exist_ok=True)
    mp4_path = os.path.join(mp4_dir, f"{hip_name}.{user_version}.mp4")
    exr_input_pattern = os.path.join(exr_folder, f"{hip_name}_{user_version}.%04d.exr")

    cmd = [
        ffmpeg_bin,
        "-y",
        "-start_number", str(start_f),
        "-framerate", "24",
        "-i", exr_input_pattern,
        "-c:v", "libx264",
        "-preset", "veryslow",
        "-crf", "0",
        "-pix_fmt", "yuv444p",
        mp4_path
    ]

    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if result.returncode != 0:
        raise hou.Error("FFmpeg conversion failed:\n" + result.stderr.decode())

    if open_after:
        try:
            if os.name == "nt":
                os.startfile(mp4_path.replace("/", "\\"))
            elif sys.platform == "darwin":
                subprocess.call(["open", mp4_path])
            else:
                subprocess.call(["xdg-open", mp4_path])
        except Exception as e:
            hou.ui.displayMessage(f"Rendered but could not open MP4:\n{str(e)}")

    # Open in MPlay by default
    first_frame_path = os.path.join(exr_folder, f"{hip_name}_{user_version}.{start_f:04d}.exr")
    open_sequence_in_mplay(first_frame_path, end_f - start_f + 1)

main()
]]></script>
  </tool>

  <tool name="flipbookBrowser" label="FlipbookBrowser" icon="$XLAB/icons/flipbookbrowser.png">
    <script scriptType="python"><![CDATA[import os
import glob
import subprocess
import numpy as np
import OpenImageIO as oiio
from PySide2 import QtWidgets, QtGui, QtCore
import hou
import re

# Close any previous instance
for w in QtWidgets.QApplication.allWidgets():
    if w.objectName() == "FlipbookImageSequenceBrowser":
        w.close()


def load_exr_thumbnail(path, size=(160, 90)):
    img = oiio.ImageInput.open(path)
    if not img:
        return None
    spec = img.spec()
    pixels = img.read_image(format=oiio.FLOAT)
    img.close()
    if pixels is None:
        return None

    w, h = spec.width, spec.height
    c = spec.nchannels if spec.nchannels is not None else 1

    pixels = np.clip(pixels, 0.0, 1.0)
    arr = (pixels * 255).astype(np.uint8)

    # Handle different channel counts
    if c == 1:
        arr = arr.reshape(h, w)
        fmt = QtGui.QImage.Format_Grayscale8
    elif c == 2:
        arr = arr.reshape(h, w, 2)
        arr = arr[:, :, 0]  # take first channel
        fmt = QtGui.QImage.Format_Grayscale8
    elif c == 3:
        arr = arr.reshape(h, w, 3)
        fmt = QtGui.QImage.Format_RGB888
    elif c >= 4:
        arr = arr.reshape(h, w, c)[:, :, :4]
        fmt = QtGui.QImage.Format_RGBA8888
    else:
        return None

    arr = np.ascontiguousarray(arr)
    qimg = QtGui.QImage(arr.data, w, h, w * arr.shape[-1], fmt).copy()
    return QtGui.QPixmap.fromImage(qimg.scaled(*size, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation))


from PySide2.QtGui import QPainter, QColor, QFont


def add_overlay_text(pixmap, resolution, frame_range):
    painter = QPainter(pixmap)
    painter.setRenderHint(QPainter.TextAntialiasing)

    margin = 6
    rect = pixmap.rect().adjusted(margin, margin, -margin, -margin)
    text = f"{resolution[0]}x{resolution[1]}\n{frame_range[0]}-{frame_range[1]}"

    painter.setPen(QColor("white"))
    painter.setFont(QFont("Segoe UI", 6, QFont.Normal))
    painter.drawText(rect, QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop, text)
    painter.end()
    return pixmap


class EXRFlipbookBrowser(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setObjectName("FlipbookImageSequenceBrowser")
        self.setWindowTitle("EXR Flipbook Browser")
        self.setMinimumSize(900, 550)

        self.setStyleSheet("""
            QWidget {
                background-color: #1e1e1e;
                color: #FFFFFF;
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                font-size: 12px;
            }
            QListWidget {
                background-color: #2c2c2c;
                border: none;
                border-radius: 6px;
                outline: none;
            }
            QListWidget::item {
                background-color: #3a3a3a;
                margin: 6px 10px;
                padding: 6px;
                border-radius: 6px;
                color: #EEE;
            }
            QListWidget::item:selected {
                background-color: #505050;
                color: #FFFFFF;
            }
            QListWidget::item:hover {
                background-color: #606060;
                color: #FFFFFF;
            }
            QPushButton {
                background-color: #bfbfbf;
                color: #1e1e1e;
                padding: 4px 4px;
                border-radius: 6px;
                font-weight: 400;
                min-width: 4px;
            }
            QPushButton:hover {
                background-color: #FFFFFF;
                color: #000000;
            }
            QPushButton:pressed {
                background-color: #d9d9d9;
                color: #000000;
            }
            QMenu {
                background-color: #2c2c2c;
                color: #FFFFFF;
                border-radius: 6px;
                padding: 4px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 6px;
            }
            QMenu::item:selected {
                background-color: #505050;
                color: #FFF;
            }
        """)

        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.setViewMode(QtWidgets.QListView.IconMode)
        self.list_widget.setIconSize(QtCore.QSize(160, 90))
        self.list_widget.setGridSize(QtCore.QSize(180, 130))
        self.list_widget.setSpacing(12)
        self.list_widget.setResizeMode(QtWidgets.QListView.Adjust)
        self.list_widget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.list_widget.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.list_widget.customContextMenuRequested.connect(self.show_context_menu)
        self.list_widget.itemDoubleClicked.connect(self.open_in_mplay)

        font = QtGui.QFont("Segoe UI", 11)
        self.list_widget.setFont(font)

        self.refresh_btn = QtWidgets.QPushButton("Refresh")
        self.refresh_btn.setFont(font)
        self.refresh_btn.clicked.connect(self.start_thumbnail_loading)

        self.mp4_btn = QtWidgets.QPushButton("Open MP4 Folder")
        self.mp4_btn.setFont(font)
        self.mp4_btn.clicked.connect(self.open_mp4_folder)

        btn_layout = QtWidgets.QHBoxLayout()
        btn_layout.addWidget(self.refresh_btn)
        btn_layout.addWidget(self.mp4_btn)
        btn_layout.addStretch()

        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.addWidget(self.list_widget)
        main_layout.addLayout(btn_layout)

        self.folders = []
        self.thumbnail_index = 0
        self.item_lookup = {}

        self.timer = QtCore.QTimer()
        self.timer.setInterval(50)
        self.timer.timeout.connect(self.load_next_thumbnail)

        QtCore.QTimer.singleShot(100, self.start_thumbnail_loading)

    def hip_root(self):
        return os.path.join(os.path.normpath(os.path.expandvars("$HIP")), "Flipbooks")

    def start_thumbnail_loading(self):
        self.list_widget.clear()
        self.item_lookup.clear()
        self.timer.stop()

        root = self.hip_root()
        if not os.path.isdir(root):
            return

        self.folders = []
        seen_paths = set()

        for name in sorted(os.listdir(root)):
            folder_path = os.path.abspath(os.path.join(root, name))
            if folder_path in seen_paths or not os.path.isdir(folder_path):
                continue

            exrs = sorted(glob.glob(os.path.join(folder_path, "*.exr")))
            if not exrs:
                continue

            seen_paths.add(folder_path)
            self.folders.append((name, folder_path, exrs))

            placeholder = QtGui.QPixmap(160, 90)
            placeholder.fill(QtGui.QColor("gray"))
            item = QtWidgets.QListWidgetItem(QtGui.QIcon(placeholder), name)
            item.setData(QtCore.Qt.UserRole, exrs)
            self.list_widget.addItem(item)
            self.item_lookup[folder_path] = item

        self.thumbnail_index = 0
        self.timer.start()

    def load_next_thumbnail(self):
        if self.thumbnail_index >= len(self.folders):
            self.timer.stop()
            return

        name, folder_path, exrs = self.folders[self.thumbnail_index]
        thumb = load_exr_thumbnail(exrs[0])
        if thumb:
            img = oiio.ImageInput.open(exrs[0])
            spec = img.spec() if img else None
            if img:
                img.close()
            resolution = (spec.width, spec.height) if spec else (0, 0)

            frames = []
            for f in exrs:
                base = os.path.splitext(os.path.basename(f))[0]
                m = re.search(r'(\d+)$', base)
                if m:
                    frames.append(int(m.group(1)))
            if frames:
                frame_range = (min(frames), max(frames))
            else:
                frame_range = (0, 0)

            overlay_pixmap = add_overlay_text(thumb.copy(), resolution, frame_range)
            self.item_lookup[folder_path].setIcon(QtGui.QIcon(overlay_pixmap))

        self.thumbnail_index += 1

    def show_context_menu(self, pos):
        items = self.list_widget.selectedItems()
        if not items:
            return
    
        folder_path = os.path.dirname(items[0].data(QtCore.Qt.UserRole)[0])
    
        menu = QtWidgets.QMenu()
        menu.addAction("Open in MPlay", lambda: self.open_in_mplay(items[0]))
        menu.addAction("Open Folder", lambda: self.open_folder(folder_path))
        menu.addAction("Copy Path", lambda: QtWidgets.QApplication.clipboard().setText(folder_path))
    
        # Remove window frame, shadow, and make transparent
        menu.setWindowFlags(menu.windowFlags() | QtCore.Qt.FramelessWindowHint | QtCore.Qt.NoDropShadowWindowHint)
        menu.setAttribute(QtCore.Qt.WA_TranslucentBackground)
        
        # Apply flat rounded style
        menu.setStyleSheet("""
            QMenu {
                background-color: rgba(40, 40, 40, 220);  /* semi-transparent dark */
                border-radius: 6px;
                padding: 2px;
                color: #ffffff;
            }
            QMenu::item {
                padding: 2px 20px;
                border-radius: 6px;
                background-color: transparent;
            }
            QMenu::item:selected {
                background-color: rgba(255, 255, 255, 50);
                color: #ffffff;
            }
        """)
    
        menu.exec_(self.list_widget.viewport().mapToGlobal(pos))


    def open_folder(self, path):
        if os.name == "nt":
            os.startfile(path)
        else:
            subprocess.Popen(["open", path])

    def open_mp4_folder(self):
        path = os.path.join(self.hip_root(), "mp4")
        os.makedirs(path, exist_ok=True)
        self.open_folder(path)

    def open_in_mplay(self, item):
        exr_sequence = item.data(QtCore.Qt.UserRole)
        if not exr_sequence:
            return

        folder = os.path.dirname(exr_sequence[0])
        files = sorted(os.path.basename(f) for f in exr_sequence)

        pattern = re.compile(r"(.*?)(\d+)(\.[^.]+)$")
        matches = [pattern.match(f) for f in files if pattern.match(f)]

        if matches:
            base = matches[0].group(1)
            start = int(matches[0].group(2))
            end = int(matches[-1].group(2))
            ext = matches[0].group(3)
            padding = len(matches[0].group(2))
            sequence = os.path.join(folder, f"{base}$F{padding}{ext}")

            subprocess.Popen(["mplay", "-f", str(start), str(end), "1", sequence])
            return

        subprocess.Popen(["mplay"] + exr_sequence)


def launch_browser():
    global flipbook_browser
    flipbook_browser = EXRFlipbookBrowser()
    flipbook_browser.show()


try:
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])
    launch_browser()
except Exception as e:
    print(f"Error: {e}")
]]></script>
  </tool>

  <tool name="renderViewer" label="RenderViewer" icon="$XLAB/icons/render.png">
    <script scriptType="python"><![CDATA[import hou
from PySide2 import QtWidgets, QtCore, QtGui
from PySide2.QtCore import QDateTime
import os
import re
import shutil
import getpass
import subprocess
import sys

try:
    import OpenImageIO as oiio
    HAS_OIIO = True
except ImportError:
    HAS_OIIO = False


def get_folder_owner(path):
    try:
        if os.name == 'nt':
            try:
                import win32security
                sd = win32security.GetFileSecurity(path, win32security.OWNER_SECURITY_INFORMATION)
                owner_sid = sd.GetSecurityDescriptorOwner()
                name, domain, _ = win32security.LookupAccountSid(None, owner_sid)
                return f"{domain}\\{name}"
            except ImportError:
                return getpass.getuser()
            except Exception as e:
                print(f"Error getting Windows owner for {path}: {e}")
                return "Unknown"
        else:
            import pwd
            stat_info = os.stat(path)
            return pwd.getpwuid(stat_info.st_uid).pw_name
    except Exception as e:
        print(f"Error getting owner for {path}: {e}")
        return "Unknown"


class RenderBrowser(QtWidgets.QMainWindow):
    def __init__(self, parent=None):
        parent = parent or hou.ui.mainQtWindow()
        super(RenderBrowser, self).__init__(parent)
        self.setWindowTitle("Render Browser")

        # â Normal Windows-style window with Minimize / Maximize / Close
        self.setWindowFlags(QtCore.Qt.Window |
                            QtCore.Qt.WindowMinimizeButtonHint |
                            QtCore.Qt.WindowMaximizeButtonHint |
                            QtCore.Qt.WindowCloseButtonHint)

        self.resize(900, 550)

        # QMainWindow needs a central widget
        central_widget = QtWidgets.QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QtWidgets.QVBoxLayout(central_widget)

        # --- Styling ---
        self.setStyleSheet(""" QWidget {
            background-color: #2b2b2b;
            color: #dddddd;
            font-family: "Segoe UI", "Arial", sans-serif;
            font-size: 8pt;
        } QHeaderView::section {
            background-color: #3c3c3c;
            color: #dddddd;
            padding: 4px;
            border: 1px solid #444;
        } QTableWidget {
            background-color: #2b2b2b;
            gridline-color: #555555;
            alternate-background-color: #3a3a3a;
        } QTableWidget::item:selected {
            background-color: #505F79;
            color: white;
        } QMenu {
            background-color: #2b2b2b;
            color: #dddddd;
            border: 1px solid #444444;
        } QMenu::item:selected {
            background-color: #505F79;
        } QLabel {
            color: #dddddd;
        } QMessageBox {
            background-color: #2b2b2b;
        }""")

        # --- Top path bar ---
        path_layout = QtWidgets.QHBoxLayout()
        self.path_edit = QtWidgets.QLineEdit()
        self.path_edit.setPlaceholderText("Set Render Directory...")
        self.path_edit.setText(self.get_initial_render_path())
        path_layout.addWidget(self.path_edit)

        button_style = """
        QPushButton {
            background-color: #bfbfbf;
            color: #1e1e1e;
            padding: 2px 2px;
            border-radius: 4px;
            font-weight: 400;
        }
        QPushButton:hover { background-color: #555555; }
        QPushButton:pressed { background-color: #222222; }
        """

        browse_button = QtWidgets.QPushButton("Browse")
        browse_button.setStyleSheet(button_style)
        browse_button.clicked.connect(self.browse_render_path)

        set_button = QtWidgets.QPushButton("Set")
        set_button.setStyleSheet(button_style)
        set_button.clicked.connect(self.set_render_path)

        refresh_button = QtWidgets.QPushButton("ð Refresh")
        refresh_button.setStyleSheet(button_style)
        refresh_button.clicked.connect(self.populate_render_table)

        path_layout.addWidget(browse_button)
        path_layout.addWidget(set_button)
        path_layout.addWidget(refresh_button)
        main_layout.addLayout(path_layout)

        # --- Render table ---
        self.render_table = QtWidgets.QTableWidget()
        self.render_table.setColumnCount(8)
        self.render_table.setHorizontalHeaderLabels([
            "Preview", "Render Layer", "Frame Range", "Frame No", "Resolution",
            "Version", "Date & Time", "User"
        ])
        self.render_table.horizontalHeader().setStretchLastSection(True)
        self.render_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.render_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.render_table.verticalHeader().setVisible(False)
        self.render_table.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.render_table.customContextMenuRequested.connect(self.show_render_context_menu)
        self.render_table.cellDoubleClicked.connect(self.handle_render_double_click)

        main_layout.addWidget(self.render_table)

        # Populate after startup
        QtCore.QTimer.singleShot(300, self.populate_render_table)

    def get_initial_render_path(self):
        if hasattr(hou.session, "last_render_path"):
            return os.path.normpath(hou.session.last_render_path)
        return os.path.normpath(os.path.join(hou.getenv("HIP") or "", "render"))

    def set_render_path(self):
        path = os.path.normpath(self.path_edit.text().strip())
        if not os.path.exists(path):
            QtWidgets.QMessageBox.warning(self, "Invalid Path", f"The path does not exist:\n{path}")
            return
        self.path_edit.setText(path)
        hou.session.last_render_path = path
        self.populate_render_table()

    def browse_render_path(self):
        selected = QtWidgets.QFileDialog.getExistingDirectory(self, "Select Render Directory", self.path_edit.text())
        if selected:
            normalized = os.path.normpath(selected)
            self.path_edit.setText(normalized)

    def generate_thumbnail(self, image_path, size=(160, 90)):
        label = QtWidgets.QLabel()
        label.setAlignment(QtCore.Qt.AlignCenter)
        label.setStyleSheet("padding: 2px; background-color: #222222; color: gray;")
        if not os.path.isfile(image_path):
            label.setText("File not found")
            return label

        ext = os.path.splitext(image_path)[1].lower()
        display_path = image_path

        if ext == ".exr" and HAS_OIIO:
            try:
                import tempfile
                buf = oiio.ImageBuf(image_path)
                tmp = tempfile.NamedTemporaryFile(suffix=".png", delete=False)
                display_path = tmp.name
                buf.write(display_path)
            except Exception:
                label.setText("EXR read error")
                return label

        reader = QtGui.QImageReader(display_path)
        reader.setAutoTransform(True)
        image = reader.read()

        if image.isNull():
            label.setText("Unsupported Format")
        else:
            pixmap = QtGui.QPixmap.fromImage(image)
            scaled_pixmap = pixmap.scaled(size[0], size[1], QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation)
            label.setPixmap(scaled_pixmap)

        if ext == ".exr" and HAS_OIIO:
            try:
                os.remove(display_path)
            except:
                pass

        return label

    def populate_render_table(self):
        try:
            self.render_table.setRowCount(0)
            render_dir = self.path_edit.text().strip()
            if not os.path.exists(render_dir):
                return
            version_folders = sorted([f for f in os.listdir(render_dir) if f.lower().startswith('v') and os.path.isdir(os.path.join(render_dir, f))])
            row = 0
            for i, version in enumerate(version_folders):
                version_path = os.path.join(render_dir, version)
                layer_folders = sorted(os.listdir(version_path))
                text_color = QtGui.QColor("#FFFFFF") if i % 2 == 0 else QtGui.QColor("#FFDAB3")
                for layer in layer_folders:
                    layer_path = os.path.join(version_path, layer)
                    if not os.path.isdir(layer_path):
                        continue
                    exr_files = [f for f in os.listdir(layer_path) if os.path.splitext(f)[1].lower() in (".exr", ".jpg", ".jpeg", ".png", ".dpx", ".tif", ".tiff")]
                    if not exr_files:
                        continue
                    exr_files.sort()
                    pattern = re.compile(r"^(.*?)(\d+)\.[^.]+$")
                    matches = [pattern.match(f) for f in exr_files]
                    frame_range = f"{int(matches[0].group(2))}-{int(matches[-1].group(2))}" if matches and all(matches) else f"1-{len(exr_files)}"
                    resolution = "Unknown"
                    try:
                        if HAS_OIIO:
                            img = oiio.ImageInput.open(os.path.join(layer_path, exr_files[0]))
                            if img:
                                spec = img.spec()
                                resolution = f"{spec.width}x{spec.height}"
                                img.close()
                    except Exception:
                        resolution = "Unknown"

                    modified_time = os.path.getmtime(layer_path)
                    datetime_str = QDateTime.fromSecsSinceEpoch(int(modified_time)).toString("yyyy-MM-dd hh:mm")
                    user = get_folder_owner(layer_path)
                    frame_count = str(len(exr_files))
                    self.render_table.insertRow(row)
                    thumb_path = os.path.join(layer_path, exr_files[len(exr_files) // 2])
                    thumb_label = self.generate_thumbnail(thumb_path)
                    self.render_table.setCellWidget(row, 0, thumb_label)
                    row_data = [layer, frame_range, frame_count, resolution, version, datetime_str, user]
                    for col, data in enumerate(row_data):
                        item = QtWidgets.QTableWidgetItem(data)
                        item.setForeground(text_color)
                        item.setData(QtCore.Qt.UserRole, layer_path)
                        item.setTextAlignment(QtCore.Qt.AlignCenter)
                        if col == 0:
                            item.setTextAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)
                        self.render_table.setItem(row, col + 1, item)
                    row += 1

            min_widths = [60, 140, 140, 80, 140, 70, 140, 140]
            for col, width in enumerate(min_widths):
                self.render_table.setColumnWidth(col, width)
                self.render_table.horizontalHeader().setMinimumSectionSize(50)
        except Exception as e:
            print("populate_render_table error:", e)

    def show_render_context_menu(self, pos):
        index = self.render_table.indexAt(pos)
        if not index.isValid():
            return
        row = index.row()
        item = self.render_table.item(row, 1)
        if not item:
            return
        folder_path = item.data(QtCore.Qt.UserRole)
        if not folder_path or not os.path.exists(folder_path):
            return
        menu = QtWidgets.QMenu()
        menu.addAction("ð Open Folder", lambda: self.open_folder(folder_path))
        menu.addAction("ð Copy Path", lambda: QtWidgets.QApplication.clipboard().setText(folder_path))
        menu.addAction("ðï¸ Delete", lambda: self.delete_render_folder(row, folder_path))
        menu.setWindowFlags(menu.windowFlags() | QtCore.Qt.FramelessWindowHint | QtCore.Qt.NoDropShadowWindowHint)
        menu.setAttribute(QtCore.Qt.WA_TranslucentBackground)
        menu.setStyleSheet("""
            QMenu {
                background-color: rgba(40, 40, 40, 220);
                border-radius: 6px;
                padding: 2px;
                color: #ffffff;
            }
            QMenu::item {
                padding: 2px 20px;
                border-radius: 6px;
                background-color: transparent;
            }
            QMenu::item:selected {
                background-color: rgba(255, 255, 255, 50);
                color: #ffffff;
            }
        """)
        menu.exec_(self.render_table.viewport().mapToGlobal(pos))

    def handle_render_double_click(self, row, column):
        layer_item = self.render_table.item(row, 1)
        version_item = self.render_table.item(row, 5)
        if not layer_item or not version_item:
            return
        folder = os.path.normpath(os.path.join(self.path_edit.text(), version_item.text(), layer_item.text()))
        if not os.path.exists(folder):
            QtWidgets.QMessageBox.warning(self, "Not Found", f"Folder not found:\n{folder}")
            return
        try:
            extensions = [".exr", ".jpg", ".jpeg", ".png", ".dpx", ".tif", ".tiff"]
            files = sorted(f for f in os.listdir(folder) if os.path.splitext(f)[1].lower() in extensions)
            pattern = re.compile(r"(.*?)(\d+)\.(exr|jpg|jpeg|png|dpx|tif|tiff)$", re.IGNORECASE)
            matches = [pattern.match(f) for f in files if pattern.match(f)]
            if matches:
                base, start = matches[0].group(1), int(matches[0].group(2))
                end = int(matches[-1].group(2))
                ext = matches[0].group(3).lower()
                padding = len(matches[0].group(2))
                sequence = os.path.join(folder, f"{base}$F{padding}.{ext}")
                try:
                    subprocess.Popen(["mplay", "-f", str(start), str(end), "1", sequence])
                    return
                except FileNotFoundError:
                    QtWidgets.QMessageBox.warning(self, "MPlay Not Found", "MPlay is not installed or not in PATH.")
            mp4s = [os.path.join(folder, f) for f in os.listdir(folder) if f.lower().endswith(".mp4")]
            if mp4s:
                if os.name == 'nt':
                    os.startfile(mp4s[0])
                elif sys.platform == 'darwin':
                    subprocess.Popen(["open", mp4s[0]])
                else:
                    subprocess.Popen(["xdg-open", mp4s[0]])
                return
            self.open_folder(folder)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))

    def delete_render_folder(self, row, path):
        confirm = QtWidgets.QMessageBox.question(self, "Confirm Delete", f"Delete:\n{path}?",
                                                 QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
        if confirm == QtWidgets.QMessageBox.Yes:
            try:
                shutil.rmtree(path)
                self.render_table.removeRow(row)
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "Delete Failed", str(e))

    def open_folder(self, folder):
        if os.name == 'nt':
            os.startfile(folder)
        elif sys.platform == 'darwin':
            subprocess.Popen(['open', folder])
        else:
            subprocess.Popen(['xdg-open', folder])


# -------------------------------
# Launch Helper
# -------------------------------
_render_browser_instance = None

def show_render_browser():
    global _render_browser_instance
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])

    if _render_browser_instance is None:
        _render_browser_instance = RenderBrowser()

        def reset_instance():
            global _render_browser_instance
            _render_browser_instance = None

        # reset when closed/destroyed
        _render_browser_instance.destroyed.connect(reset_instance)

    _render_browser_instance.show()
    _render_browser_instance.raise_()
    _render_browser_instance.activateWindow()

    if not QtWidgets.QApplication.instance():
        app.exec_()


# -------------------------------
# Run
# -------------------------------
show_render_browser()
]]></script>
  </tool>

  <tool name="xCopy" label="xCopy" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
import os
from datetime import datetime

# Get selected nodes
nodes = hou.selectedNodes()
if not nodes:
    raise Exception("No nodes selected")

# Ensure all nodes are from the same parent
parent = nodes[0].parent()

# Get namespace (parent path)
namespace = parent.path().replace("/", "_").strip("_")

# Get current date & time
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

# Create a subnet at the same level
subnet_name = f"multiNode_{namespace}_{timestamp}_subnet"
subnet = parent.createNode("subnet", subnet_name)

# Dictionary to map original node -> copied node
node_map = {}

# Copy nodes into the subnet
for node in nodes:
    copied = node.copyTo(subnet)
    copied.setName(node.name(), unique_name=True)
    copied.moveToGoodPosition()
    node_map[node] = copied

# Recreate connections inside the subnet
for node in nodes:
    copied_node = node_map[node]
    for i in range(node.inputs().__len__()):
        input_node = node.input(i)
        if input_node in node_map:
            copied_node.setInput(i, node_map[input_node])

# Layout subnet contents
subnet.layoutChildren()

# Prepare export path
xlab_path = os.environ.get("XLAB")
if not xlab_path:
    raise Exception("XLAB environment variable not set")
export_dir = os.path.join(xlab_path, "nodedata")
os.makedirs(export_dir, exist_ok=True)

# Define HDA path
hda_path = os.path.join(export_dir, subnet.name() + ".hda")

# Create HDA from the subnet and ignore external references
subnet.createDigitalAsset(
    name=subnet.name(),
    hda_file_name=hda_path,
    description="Exported multiple nodes via script (with connections)",
    ignore_external_references=True
)

print(f"HDA exported to: {hda_path}")
print(f"Namespace: {namespace}")
print(f"Timestamp: {timestamp}")
]]></script>
  </tool>

  <tool name="xPaste" label="xPaste" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
import os

# ---------------------------
# 1. Load HDA
# ---------------------------

xlab_path = os.environ.get("XLAB")
hda_dir = os.path.join(xlab_path, "nodedata")

hda_files = [f for f in os.listdir(hda_dir) if f.endswith(".hda")]
if not hda_files:
    raise Exception("No HDA files found in folder.")

selected_index = hou.ui.selectFromList(hda_files, message="Select HDA", exclusive=True)
if not selected_index:
    raise Exception("No HDA selected")

selected_hda = hda_files[selected_index[0]]
hda_path = os.path.join(hda_dir, selected_hda)

# Temporarily load HDA
hou.hda.installFile(hda_path)

definitions = hou.hda.definitionsInFile(hda_path)
if not definitions:
    raise Exception("No definitions found in HDA file")

hda_def = definitions[0]
node_type_name = hda_def.nodeTypeName()

# ---------------------------
# 2. Detect parent network from filename
# ---------------------------

parts = selected_hda.split("_")
if len(parts) >= 2:
    namespace_name = parts[1]  # Assuming second part is namespace
    parent = hou.node("/" + namespace_name)
    if parent is None:
        print(f"Namespace '{namespace_name}' not found. Using /obj instead.")
        parent = hou.node("/obj")
else:
    parent = hou.node("/obj")

# ---------------------------
# 3. Create HDA node
# ---------------------------

hda_node = parent.createNode(node_type_name)
hda_node.moveToGoodPosition()
print(f"HDA loaded and node created: {hda_node.path()}")

# ---------------------------
# 4. Unlock and extract internal nodes with connections
# ---------------------------

hda_node.allowEditingOfContents()
internal_nodes = hda_node.children()

if not internal_nodes:
    print("HDA is empty, nothing to copy.")
else:
    # Map original node -> copied node
    node_map = {}
    for n in internal_nodes:
        copied = n.copyTo(parent)
        copied.moveToGoodPosition()
        node_map[n] = copied

    # Recreate connections
    for orig_node in internal_nodes:
        copied_node = node_map[orig_node]
        for i, input_node in enumerate(orig_node.inputs()):
            if input_node in node_map:
                copied_node.setInput(i, node_map[input_node])

    print(f"Copied {len(internal_nodes)} nodes with connections to {parent.path()}.")

# ---------------------------
# 5. Delete original HDA node
# ---------------------------

hda_node.destroy()
print("Original HDA node deleted.")
]]></script>
  </tool>
</shelfDocument>
